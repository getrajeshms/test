{"file_contents":{"data_generator.py":{"content":"import pandas as pd\nimport numpy as np\nfrom scipy import stats\nimport random\n\ndef generate_synthetic_data(n_samples=1000, random_state=42):\n    \"\"\"\n    Generate synthetic H. pylori patient data based on medical literature and realistic distributions\n    \n    Parameters:\n    n_samples (int): Number of synthetic patient records to generate\n    random_state (int): Random seed for reproducibility\n    \n    Returns:\n    pandas.DataFrame: Synthetic patient dataset with all relevant features\n    \"\"\"\n    \n    np.random.seed(random_state)\n    random.seed(random_state)\n    \n    data = {}\n    \n    # Demographics\n    data['Age'] = np.random.normal(45, 15, n_samples).astype(int)\n    data['Age'] = np.clip(data['Age'], 18, 75)  # Age range 18-75\n    \n    data['Sex'] = np.random.binomial(1, 0.52, n_samples)  # 52% male\n    \n    # Residence: 0=Urban, 1=County, 2=Suburban, 3=Village\n    residence_probs = [0.35, 0.25, 0.25, 0.15]\n    data['Residence'] = np.random.choice(4, n_samples, p=residence_probs)\n    \n    # Education: 0=Primary, 1=Secondary, 2=College, 3=Bachelor, 4=Postgraduate\n    education_probs = [0.15, 0.25, 0.25, 0.25, 0.10]\n    data['Education'] = np.random.choice(5, n_samples, p=education_probs)\n    \n    # Marital Status: 0=Unmarried, 1=Married\n    data['Marital_Status'] = np.random.binomial(1, 0.65, n_samples)  # 65% married\n    \n    # Family Size (1-8 members)\n    data['Family_Size'] = np.random.poisson(3.2, n_samples) + 1\n    data['Family_Size'] = np.clip(data['Family_Size'], 1, 8)\n    \n    # Clinical History and Symptoms\n    data['BMI'] = np.random.normal(25.5, 4.2, n_samples)\n    data['BMI'] = np.clip(data['BMI'], 16, 45)\n    \n    # Non-atrophic gastritis history (higher in H. pylori positive)\n    base_gastritis_rate = 0.20\n    data['Gastritis_History'] = np.random.binomial(1, base_gastritis_rate, n_samples)\n    \n    # Ulcer/Peptic ulcer history\n    base_ulcer_rate = 0.15\n    data['Ulcer_History'] = np.random.binomial(1, base_ulcer_rate, n_samples)\n    \n    # Laboratory Values\n    data['Albumin'] = np.random.normal(42, 4.5, n_samples)\n    data['Albumin'] = np.clip(data['Albumin'], 28, 52)\n    \n    data['WBC_Count'] = np.random.normal(7.2, 1.8, n_samples)\n    data['WBC_Count'] = np.clip(data['WBC_Count'], 3.5, 12)\n    \n    data['Lymphocyte_Count'] = np.random.normal(2.1, 0.6, n_samples)\n    data['Lymphocyte_Count'] = np.clip(data['Lymphocyte_Count'], 0.8, 4.5)\n    \n    data['Neutrophil_Count'] = np.random.normal(4.2, 1.2, n_samples)\n    data['Neutrophil_Count'] = np.clip(data['Neutrophil_Count'], 1.5, 8.5)\n    \n    data['RBC_Count'] = np.random.normal(4.5, 0.4, n_samples)\n    data['RBC_Count'] = np.clip(data['RBC_Count'], 3.2, 5.8)\n    \n    # Hemoglobin (slightly lower in H. pylori positive due to potential iron deficiency)\n    data['Hemoglobin'] = np.random.normal(135, 15, n_samples)\n    data['Hemoglobin'] = np.clip(data['Hemoglobin'], 90, 170)\n    \n    # Lifestyle Factors\n    # Smoking: 0=None, 1=1-5/day, 2=6-10/day, 3=>10/day\n    smoking_probs = [0.65, 0.20, 0.10, 0.05]\n    data['Smoking'] = np.random.choice(4, n_samples, p=smoking_probs)\n    \n    # Alcohol: 0=None, 1=Monthly, 2=Weekly, 3=3+/Weekly\n    alcohol_probs = [0.45, 0.25, 0.20, 0.10]\n    data['Alcohol'] = np.random.choice(4, n_samples, p=alcohol_probs)\n    \n    # Water source: 0=Tap, 1=Purified, 2=Mineral, 3=Other\n    water_probs = [0.40, 0.35, 0.20, 0.05]\n    data['Water_Source'] = np.random.choice(4, n_samples, p=water_probs)\n    \n    # Pickled food consumption: 0=Rare, 1=Now&then, 2=Frequent, 3=Daily\n    pickled_probs = [0.30, 0.40, 0.20, 0.10]\n    data['Pickled_Food'] = np.random.choice(4, n_samples, p=pickled_probs)\n    \n    # Handwashing frequency: 0=Rarely, 1=Now&then, 2=Frequent, 3=Daily\n    handwashing_probs = [0.05, 0.15, 0.35, 0.45]\n    data['Handwashing'] = np.random.choice(4, n_samples, p=handwashing_probs)\n    \n    # Tableware sharing frequency: 0=Rare, 1=Now&then, 2=Frequent, 3=Daily\n    sharing_probs = [0.25, 0.35, 0.25, 0.15]\n    data['Tableware_Sharing'] = np.random.choice(4, n_samples, p=sharing_probs)\n    \n    # Family History\n    data['Family_Pylori_History'] = np.random.binomial(1, 0.18, n_samples)\n    data['Family_Gastritis_History'] = np.random.binomial(1, 0.22, n_samples)\n    \n    # Endoscopy/Imaging Features (Optional - some missing values)\n    # Nodularity: gastric nodularity on endoscopy\n    nodularity_available = np.random.binomial(1, 0.7, n_samples)  # 70% have endoscopy data\n    data['Nodularity'] = np.where(\n        nodularity_available, \n        np.random.binomial(1, 0.25, n_samples), \n        -1  # Missing value indicator\n    )\n    \n    # Gastric mucosal redness\n    redness_available = np.random.binomial(1, 0.7, n_samples)\n    data['Gastric_Redness'] = np.where(\n        redness_available,\n        np.random.binomial(1, 0.35, n_samples),\n        -1  # Missing value indicator\n    )\n    \n    # Convert to DataFrame\n    df = pd.DataFrame(data)\n    \n    # Generate H. Pylori infection status based on realistic risk factors\n    # Create a risk score based on known risk factors\n    risk_score = (\n        0.05 * (df['Age'] - 40) +  # Age factor\n        0.1 * df['Sex'] +  # Male slightly higher risk\n        0.15 * (df['Residence'] > 1) +  # Rural residence\n        -0.1 * df['Education'] +  # Higher education protective\n        0.2 * df['Family_Size'] / 8 +  # Crowded living\n        0.3 * df['Gastritis_History'] +  # Previous gastritis\n        0.25 * df['Ulcer_History'] +  # Previous ulcer\n        -0.05 * (df['Albumin'] - 40) / 10 +  # Nutritional status\n        0.1 * df['Smoking'] / 3 +  # Smoking\n        -0.15 * df['Handwashing'] / 3 +  # Hygiene\n        0.1 * df['Tableware_Sharing'] / 3 +  # Sharing utensils\n        0.2 * df['Family_Pylori_History'] +  # Family history\n        0.1 * df['Family_Gastritis_History'] +  # Family gastritis\n        0.1 * df['Pickled_Food'] / 3 +  # Dietary factors\n        0.05 * (df['Water_Source'] == 3) +  # Poor water quality\n        np.random.normal(0, 0.3, n_samples)  # Random variation\n    )\n    \n    # Convert risk score to probability using sigmoid function\n    probability = 1 / (1 + np.exp(-risk_score))\n    \n    # Generate binary outcome with realistic prevalence (around 30-40%)\n    # Adjust baseline to get desired prevalence\n    adjusted_prob = (probability - probability.mean() + 0.35)\n    adjusted_prob = np.clip(adjusted_prob, 0.05, 0.95)\n    \n    df['H_Pylori_Infection'] = np.random.binomial(1, adjusted_prob, n_samples)\n    \n    # Adjust some features based on infection status to make relationships more realistic\n    infection_mask = df['H_Pylori_Infection'] == 1\n    \n    # H. pylori positive patients more likely to have gastritis/ulcer history\n    df.loc[infection_mask & (np.random.random(n_samples) < 0.3), 'Gastritis_History'] = 1\n    df.loc[infection_mask & (np.random.random(n_samples) < 0.2), 'Ulcer_History'] = 1\n    \n    # Slightly lower hemoglobin in infected patients (iron deficiency)\n    df.loc[infection_mask, 'Hemoglobin'] -= np.random.normal(5, 3, infection_mask.sum())\n    df['Hemoglobin'] = np.clip(df['Hemoglobin'], 90, 170)\n    \n    # Higher WBC in some infected patients (inflammatory response)\n    inflammatory_response = infection_mask & (np.random.random(n_samples) < 0.3)\n    df.loc[inflammatory_response, 'WBC_Count'] += np.random.normal(1.5, 0.8, inflammatory_response.sum())\n    df['WBC_Count'] = np.clip(df['WBC_Count'], 3.5, 12)\n    \n    # Endoscopy findings more common in infected patients\n    df.loc[infection_mask & (df['Nodularity'] != -1) & (np.random.random(n_samples) < 0.4), 'Nodularity'] = 1\n    df.loc[infection_mask & (df['Gastric_Redness'] != -1) & (np.random.random(n_samples) < 0.5), 'Gastric_Redness'] = 1\n    \n    # Round numeric values appropriately\n    df['Age'] = df['Age'].astype(int)\n    df['Family_Size'] = df['Family_Size'].astype(int)\n    df['BMI'] = df['BMI'].round(1)\n    df['Albumin'] = df['Albumin'].round(1)\n    df['WBC_Count'] = df['WBC_Count'].round(1)\n    df['Lymphocyte_Count'] = df['Lymphocyte_Count'].round(1)\n    df['Neutrophil_Count'] = df['Neutrophil_Count'].round(1)\n    df['RBC_Count'] = df['RBC_Count'].round(1)\n    df['Hemoglobin'] = df['Hemoglobin'].round(0).astype(int)\n    \n    # Add feature labels for interpretability\n    feature_labels = {\n        'Age': 'Patient age in years',\n        'Sex': 'Biological sex (0=Female, 1=Male)',\n        'Residence': 'Type of residence (0=Urban, 1=County, 2=Suburban, 3=Village)',\n        'Education': 'Education level (0=Primary, 1=Secondary, 2=College, 3=Bachelor, 4=Postgraduate)',\n        'Marital_Status': 'Marital status (0=Unmarried, 1=Married)',\n        'Family_Size': 'Number of household members',\n        'BMI': 'Body Mass Index (kg/m²)',\n        'Gastritis_History': 'History of non-atrophic gastritis (0=No, 1=Yes)',\n        'Ulcer_History': 'History of ulcer/peptic ulcer (0=No, 1=Yes)',\n        'Albumin': 'Serum albumin concentration (g/L)',\n        'WBC_Count': 'White blood cell count (10⁹/L)',\n        'Lymphocyte_Count': 'Absolute lymphocyte count (10⁹/L)',\n        'Neutrophil_Count': 'Absolute neutrophil count (10⁹/L)',\n        'RBC_Count': 'Red blood cell count (10¹²/L)',\n        'Hemoglobin': 'Hemoglobin level (g/L)',\n        'Smoking': 'Smoking status (0=None, 1=1-5/day, 2=6-10/day, 3=>10/day)',\n        'Alcohol': 'Alcohol consumption (0=None, 1=Monthly, 2=Weekly, 3=3+/Weekly)',\n        'Water_Source': 'Drinking water source (0=Tap, 1=Purified, 2=Mineral, 3=Other)',\n        'Pickled_Food': 'Pickled food consumption (0=Rare, 1=Now&then, 2=Frequent, 3=Daily)',\n        'Handwashing': 'Handwashing frequency (0=Rarely, 1=Now&then, 2=Frequent, 3=Daily)',\n        'Tableware_Sharing': 'Frequency of sharing tableware (0=Rare, 1=Now&then, 2=Frequent, 3=Daily)',\n        'Family_Pylori_History': 'Family history of H. pylori (0=No, 1=Yes)',\n        'Family_Gastritis_History': 'Family history of gastritis (0=No, 1=Yes)',\n        'Nodularity': 'Gastric nodularity on endoscopy (0=No, 1=Yes, -1=Not available)',\n        'Gastric_Redness': 'Gastric mucosal redness (0=No, 1=Yes, -1=Not available)',\n        'H_Pylori_Infection': 'H. pylori infection status (0=Negative, 1=Positive)'\n    }\n    \n    # Add metadata\n    df.attrs['feature_labels'] = feature_labels\n    df.attrs['n_samples'] = n_samples\n    df.attrs['prevalence'] = df['H_Pylori_Infection'].mean()\n    \n    return df\n\ndef get_data_description():\n    \"\"\"\n    Returns detailed description of the synthetic dataset structure and ranges\n    \"\"\"\n    description = {\n        'demographics': {\n            'Age': {'range': '18-75 years', 'distribution': 'Normal(45, 15)', 'type': 'continuous'},\n            'Sex': {'values': '0=Female, 1=Male', 'prevalence': '52% male', 'type': 'binary'},\n            'Residence': {'values': '0=Urban, 1=County, 2=Suburban, 3=Village', 'distribution': '[35%, 25%, 25%, 15%]', 'type': 'categorical'},\n            'Education': {'values': '0=Primary, 1=Secondary, 2=College, 3=Bachelor, 4=Postgraduate', 'distribution': '[15%, 25%, 25%, 25%, 10%]', 'type': 'ordinal'},\n            'Marital_Status': {'values': '0=Unmarried, 1=Married', 'prevalence': '65% married', 'type': 'binary'},\n            'Family_Size': {'range': '1-8 members', 'distribution': 'Poisson(3.2)', 'type': 'count'}\n        },\n        'clinical': {\n            'BMI': {'range': '16-45 kg/m²', 'distribution': 'Normal(25.5, 4.2)', 'type': 'continuous'},\n            'Gastritis_History': {'values': '0=No, 1=Yes', 'prevalence': '~20%', 'type': 'binary'},\n            'Ulcer_History': {'values': '0=No, 1=Yes', 'prevalence': '~15%', 'type': 'binary'}\n        },\n        'laboratory': {\n            'Albumin': {'range': '28-52 g/L', 'distribution': 'Normal(42, 4.5)', 'type': 'continuous'},\n            'WBC_Count': {'range': '3.5-12 ×10⁹/L', 'distribution': 'Normal(7.2, 1.8)', 'type': 'continuous'},\n            'Lymphocyte_Count': {'range': '0.8-4.5 ×10⁹/L', 'distribution': 'Normal(2.1, 0.6)', 'type': 'continuous'},\n            'Neutrophil_Count': {'range': '1.5-8.5 ×10⁹/L', 'distribution': 'Normal(4.2, 1.2)', 'type': 'continuous'},\n            'RBC_Count': {'range': '3.2-5.8 ×10¹²/L', 'distribution': 'Normal(4.5, 0.4)', 'type': 'continuous'},\n            'Hemoglobin': {'range': '90-170 g/L', 'distribution': 'Normal(135, 15)', 'type': 'continuous'}\n        },\n        'lifestyle': {\n            'Smoking': {'values': '0=None, 1=1-5/day, 2=6-10/day, 3=>10/day', 'distribution': '[65%, 20%, 10%, 5%]', 'type': 'ordinal'},\n            'Alcohol': {'values': '0=None, 1=Monthly, 2=Weekly, 3=3+/Weekly', 'distribution': '[45%, 25%, 20%, 10%]', 'type': 'ordinal'},\n            'Water_Source': {'values': '0=Tap, 1=Purified, 2=Mineral, 3=Other', 'distribution': '[40%, 35%, 20%, 5%]', 'type': 'categorical'},\n            'Pickled_Food': {'values': '0=Rare, 1=Now&then, 2=Frequent, 3=Daily', 'distribution': '[30%, 40%, 20%, 10%]', 'type': 'ordinal'},\n            'Handwashing': {'values': '0=Rarely, 1=Now&then, 2=Frequent, 3=Daily', 'distribution': '[5%, 15%, 35%, 45%]', 'type': 'ordinal'},\n            'Tableware_Sharing': {'values': '0=Rare, 1=Now&then, 2=Frequent, 3=Daily', 'distribution': '[25%, 35%, 25%, 15%]', 'type': 'ordinal'}\n        },\n        'family_history': {\n            'Family_Pylori_History': {'values': '0=No, 1=Yes', 'prevalence': '~18%', 'type': 'binary'},\n            'Family_Gastritis_History': {'values': '0=No, 1=Yes', 'prevalence': '~22%', 'type': 'binary'}\n        },\n        'endoscopy': {\n            'Nodularity': {'values': '0=No, 1=Yes, -1=Not available', 'availability': '70%', 'type': 'binary_with_missing'},\n            'Gastric_Redness': {'values': '0=No, 1=Yes, -1=Not available', 'availability': '70%', 'type': 'binary_with_missing'}\n        },\n        'target': {\n            'H_Pylori_Infection': {'values': '0=Negative, 1=Positive', 'prevalence': '~35%', 'type': 'binary'}\n        }\n    }\n    \n    return description\n\nif __name__ == \"__main__\":\n    # Test data generation\n    print(\"Generating synthetic H. pylori dataset...\")\n    df = generate_synthetic_data(1000)\n    \n    print(f\"Generated dataset shape: {df.shape}\")\n    print(f\"H. pylori prevalence: {df['H_Pylori_Infection'].mean():.3f}\")\n    print(\"\\nFirst 5 rows:\")\n    print(df.head())\n    \n    print(\"\\nDataset summary:\")\n    print(df.describe())\n","size_bytes":14314},"app.py":{"content":"import streamlit as st\nimport pandas as pd\nimport numpy as np\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nimport joblib\nimport os\nfrom data_generator import generate_synthetic_data\nfrom ml_pipeline import MLPipeline\nfrom ai_recommendations import get_ai_treatment_recommendation\nfrom model_utils import ModelUtils\n\n# Set page configuration\nst.set_page_config(\n    page_title=\"PyloScan - H. Pylori Infection Prediction\",\n    page_icon=\"🔬\",\n    layout=\"wide\",\n    initial_sidebar_state=\"expanded\"\n)\n\n# Custom CSS for better styling\nst.markdown(\"\"\"\n<style>\n    .main-header {\n        font-size: 2.5rem;\n        color: #1f77b4;\n        text-align: center;\n        margin-bottom: 2rem;\n    }\n    .prediction-box {\n        padding: 1rem;\n        border-radius: 10px;\n        margin: 1rem 0;\n    }\n    .high-risk {\n        background-color: #ffebee;\n        border: 2px solid #f44336;\n    }\n    .medium-risk {\n        background-color: #fff3e0;\n        border: 2px solid #ff9800;\n    }\n    .low-risk {\n        background-color: #e8f5e8;\n        border: 2px solid #4caf50;\n    }\n    .metric-card {\n        background-color: #f8f9fa;\n        padding: 1rem;\n        border-radius: 8px;\n        border: 1px solid #dee2e6;\n        text-align: center;\n    }\n</style>\n\"\"\", unsafe_allow_html=True)\n\nclass HPyloriApp:\n    def __init__(self):\n        # Check if model is already loaded in session state\n        if 'ml_pipeline_obj' in st.session_state:\n            self.ml_pipeline = st.session_state.ml_pipeline_obj\n        else:\n            self.ml_pipeline = None\n        self.model_utils = ModelUtils()\n        \n    def load_or_train_model(self):\n        \"\"\"Load existing model\"\"\"\n        if os.path.exists('models/best_model.joblib') and os.path.exists('models/preprocessor.joblib'):\n            try:\n                pipeline = MLPipeline()\n                pipeline.load_model('models/best_model.joblib', 'models/preprocessor.joblib')\n                # Store in session state for persistence across page interactions\n                st.session_state.ml_pipeline_obj = pipeline\n                self.ml_pipeline = pipeline\n                return True\n            except Exception as e:\n                st.error(f\"Error loading model: {e}\")\n                return False\n        return False\n    \n\n    def render_sidebar(self):\n        \"\"\"Render sidebar for navigation\"\"\"\n        st.sidebar.title(\"🔬 H. Pylori Prediction\")\n        \n        # Display model info in sidebar\n        if self.ml_pipeline and hasattr(self.ml_pipeline, 'best_model_name'):\n            st.sidebar.info(f\"**Model:** {self.ml_pipeline.best_model_name}\")\n            if hasattr(self.ml_pipeline, 'model_results') and self.ml_pipeline.best_model_name in self.ml_pipeline.model_results:\n                metrics = self.ml_pipeline.model_results[self.ml_pipeline.best_model_name]\n                st.sidebar.metric(\"ROC-AUC\", f\"{metrics['roc_auc']:.3f}\")\n        \n        st.sidebar.markdown(\"---\")\n        \n        # AI Configuration in Sidebar (always accessible)\n        st.sidebar.subheader(\"🤖 AI Configuration\")\n        \n        # Check for environment variables\n        env_openai = os.environ.get(\"OPENAI_API_KEY\", \"\")\n        env_gemini = os.environ.get(\"GEMINI_API_KEY\", \"\")\n        \n        # Auto-configure if environment keys exist (outside expanders so they always run)\n        if env_openai and 'custom_openai_key' not in st.session_state:\n            st.session_state['custom_openai_key'] = env_openai\n            st.session_state['openai_configured'] = True\n        \n        if env_gemini and 'custom_gemini_key' not in st.session_state:\n            st.session_state['custom_gemini_key'] = env_gemini\n            st.session_state['gemini_configured'] = True\n        \n        # OpenAI Configuration\n        with st.sidebar.expander(\"OpenAI Setup\", expanded=False):\n            if env_openai:\n                st.success(\"✅ API key in environment\")\n                use_env_openai = st.checkbox(\"Use env key\", value=True, key=\"use_env_openai\")\n            else:\n                use_env_openai = False\n                st.info(\"No env key found\")\n            \n            if not use_env_openai:\n                openai_key = st.text_input(\n                    \"OpenAI API Key\",\n                    type=\"password\",\n                    value=st.session_state.get('custom_openai_key', ''),\n                    key=\"openai_input\"\n                )\n                if openai_key:\n                    st.session_state['custom_openai_key'] = openai_key\n                    st.session_state['openai_configured'] = True\n            else:\n                st.session_state['openai_configured'] = True\n                st.session_state['custom_openai_key'] = env_openai\n        \n        # Gemini Configuration\n        with st.sidebar.expander(\"Google Gemini Setup\", expanded=False):\n            if env_gemini:\n                st.success(\"✅ API key in environment\")\n                use_env_gemini = st.checkbox(\"Use env key\", value=True, key=\"use_env_gemini\")\n            else:\n                use_env_gemini = False\n                st.info(\"No env key found\")\n            \n            if not use_env_gemini:\n                gemini_key = st.text_input(\n                    \"Gemini API Key\",\n                    type=\"password\",\n                    value=st.session_state.get('custom_gemini_key', ''),\n                    key=\"gemini_input\"\n                )\n                if gemini_key:\n                    st.session_state['custom_gemini_key'] = gemini_key\n                    st.session_state['gemini_configured'] = True\n            else:\n                st.session_state['gemini_configured'] = True\n                st.session_state['custom_gemini_key'] = env_gemini\n        \n        # Check configuration status (runs even when expanders are closed)\n        has_openai = bool(st.session_state.get('custom_openai_key', ''))\n        has_gemini = bool(st.session_state.get('custom_gemini_key', ''))\n        \n        # Update configured flags based on actual key presence\n        if has_openai:\n            st.session_state['openai_configured'] = True\n        if has_gemini:\n            st.session_state['gemini_configured'] = True\n        \n        # AI Provider Selection\n        ai_options = []\n        if st.session_state.get('openai_configured', False):\n            ai_options.append(\"OpenAI GPT\")\n        if st.session_state.get('gemini_configured', False):\n            ai_options.append(\"Google Gemini\")\n        \n        if ai_options:\n            if 'preferred_ai' not in st.session_state:\n                st.session_state['preferred_ai'] = ai_options[0]\n            \n            preferred = st.sidebar.selectbox(\n                \"AI Provider\",\n                ai_options,\n                index=ai_options.index(st.session_state.get('preferred_ai', ai_options[0]))\n            )\n            st.session_state['preferred_ai'] = preferred\n            st.sidebar.success(f\"✅ Using {preferred}\")\n        else:\n            st.sidebar.warning(\"⚠️ Configure AI for recommendations\")\n        \n        st.sidebar.markdown(\"---\")\n        \n        # Page Navigation\n        pages = [\n            \"Patient Prediction\",\n            \"Model Performance\"\n        ]\n        \n        return st.sidebar.selectbox(\"Select Page\", pages)\n    \n    def render_patient_input_form(self):\n        \"\"\"Render patient input form\"\"\"\n        st.subheader(\"Patient Information\")\n        \n        col1, col2, col3 = st.columns(3)\n        \n        with col1:\n            st.write(\"**Demographics**\")\n            age = st.number_input(\"Age (years)\", min_value=18, max_value=75, value=35)\n            sex = st.selectbox(\"Sex\", [\"Male\", \"Female\"])\n            residence = st.selectbox(\"Residence\", [\"Urban\", \"County\", \"Suburban\", \"Village\"])\n            education = st.selectbox(\"Education Level\", \n                                   [\"Primary\", \"Secondary\", \"College\", \"Bachelor\", \"Postgraduate\"])\n            marital_status = st.selectbox(\"Marital Status\", [\"Unmarried\", \"Married\"])\n            \n        with col2:\n            st.write(\"**Clinical History & Symptoms**\")\n            bmi = st.number_input(\"BMI (kg/m²)\", min_value=15.0, max_value=45.0, value=25.0, step=0.1)\n            gastritis_history = st.selectbox(\"Non-atrophic gastritis history\", [\"No\", \"Yes\"])\n            ulcer_history = st.selectbox(\"Ulcer/Peptic ulcer history\", [\"No\", \"Yes\"])\n            \n        with col3:\n            st.write(\"**Laboratory Values**\")\n            albumin = st.number_input(\"Albumin (g/L)\", min_value=25.0, max_value=55.0, value=40.0, step=0.1)\n            wbc = st.number_input(\"WBC count (10⁹/L)\", min_value=3.0, max_value=15.0, value=7.0, step=0.1)\n            lymphocyte = st.number_input(\"Lymphocyte count (10⁹/L)\", min_value=0.5, max_value=5.0, value=2.0, step=0.1)\n            neutrophil = st.number_input(\"Neutrophil count (10⁹/L)\", min_value=1.0, max_value=10.0, value=4.0, step=0.1)\n            rbc = st.number_input(\"RBC count (10¹²/L)\", min_value=3.0, max_value=6.0, value=4.5, step=0.1)\n            hemoglobin = st.number_input(\"Hemoglobin (g/L)\", min_value=80.0, max_value=180.0, value=130.0, step=1.0)\n        \n        col4, col5 = st.columns(2)\n        \n        with col4:\n            st.write(\"**Lifestyle Factors**\")\n            smoking = st.selectbox(\"Smoking Status\", [\"None\", \"1-5/day\", \"6-10/day\", \">10/day\"])\n            alcohol = st.selectbox(\"Alcohol Consumption\", [\"None\", \"Monthly\", \"Weekly\", \"3+/Weekly\"])\n            water_source = st.selectbox(\"Drinking Water Source\", [\"Tap\", \"Purified\", \"Mineral\", \"Other\"])\n            \n        with col5:\n            st.write(\"**Dietary Factors**\")\n            pickled_food = st.selectbox(\"Pickled food consumption\", [\"Rare\", \"Now & then\", \"Frequent\", \"Daily\"])\n            handwashing = st.selectbox(\"Handwashing frequency\", [\"Rarely\", \"Now & then\", \"Frequent\", \"Daily\"])\n            tableware_sharing = st.selectbox(\"Frequency of sharing tableware/utensils\", \n                                           [\"Rare\", \"Now & then\", \"Frequent\", \"Daily\"])\n            family_history = st.selectbox(\"Family history of pylori infection\", [\"No\", \"Yes\"])\n            gastritis_family = st.selectbox(\"Family history of gastritis\", [\"No\", \"Yes\"])\n            \n        # Optional endoscopy features\n        st.write(\"**Endoscopy/Imaging Features (Optional)**\")\n        col6, col7 = st.columns(2)\n        \n        with col6:\n            nodularity = st.selectbox(\"Gastric nodularity on endoscopy\", [\"No\", \"Yes\", \"Not Available\"])\n            redness = st.selectbox(\"Gastric mucosal redness on endoscopy\", [\"No\", \"Yes\", \"Not Available\"])\n            \n        # Create patient data dictionary\n        patient_data = {\n            'Age': age,\n            'Sex': 1 if sex == \"Male\" else 0,\n            'Residence': {\"Urban\": 0, \"County\": 1, \"Suburban\": 2, \"Village\": 3}[residence],\n            'Education': {\"Primary\": 0, \"Secondary\": 1, \"College\": 2, \"Bachelor\": 3, \"Postgraduate\": 4}[education],\n            'Marital_Status': 1 if marital_status == \"Married\" else 0,\n            'Family_Size': 3,  # Default value\n            'BMI': bmi,\n            'Gastritis_History': 1 if gastritis_history == \"Yes\" else 0,\n            'Ulcer_History': 1 if ulcer_history == \"Yes\" else 0,\n            'Albumin': albumin,\n            'WBC_Count': wbc,\n            'Lymphocyte_Count': lymphocyte,\n            'Neutrophil_Count': neutrophil,\n            'RBC_Count': rbc,\n            'Hemoglobin': hemoglobin,\n            'Smoking': {\"None\": 0, \"1-5/day\": 1, \"6-10/day\": 2, \">10/day\": 3}[smoking],\n            'Alcohol': {\"None\": 0, \"Monthly\": 1, \"Weekly\": 2, \"3+/Weekly\": 3}[alcohol],\n            'Water_Source': {\"Tap\": 0, \"Purified\": 1, \"Mineral\": 2, \"Other\": 3}[water_source],\n            'Pickled_Food': {\"Rare\": 0, \"Now & then\": 1, \"Frequent\": 2, \"Daily\": 3}[pickled_food],\n            'Handwashing': {\"Rarely\": 0, \"Now & then\": 1, \"Frequent\": 2, \"Daily\": 3}[handwashing],\n            'Tableware_Sharing': {\"Rare\": 0, \"Now & then\": 1, \"Frequent\": 2, \"Daily\": 3}[tableware_sharing],\n            'Family_Pylori_History': 1 if family_history == \"Yes\" else 0,\n            'Family_Gastritis_History': 1 if gastritis_family == \"Yes\" else 0,\n            'Nodularity': 1 if nodularity == \"Yes\" else 0 if nodularity == \"No\" else -1,\n            'Gastric_Redness': 1 if redness == \"Yes\" else 0 if redness == \"No\" else -1\n        }\n        \n        return patient_data\n    \n    def predict_and_display_results(self, patient_data):\n        \"\"\"Make prediction and display results\"\"\"\n        if self.ml_pipeline is None:\n            st.error(\"Model not loaded. Please train the model first.\")\n            return\n        \n        # Convert to DataFrame\n        patient_df = pd.DataFrame([patient_data])\n        \n        # Make prediction\n        prediction_proba = self.ml_pipeline.predict_proba(patient_df)[0]\n        prediction = self.ml_pipeline.predict(patient_df)[0]\n        \n        # Determine risk level\n        risk_prob = prediction_proba[1]  # Probability of infection\n        if risk_prob >= 0.7:\n            risk_level = \"High\"\n            risk_class = \"high-risk\"\n            risk_color = \"#f44336\"\n        elif risk_prob >= 0.4:\n            risk_level = \"Medium\"\n            risk_class = \"medium-risk\"\n            risk_color = \"#ff9800\"\n        else:\n            risk_level = \"Low\"\n            risk_class = \"low-risk\"\n            risk_color = \"#4caf50\"\n        \n        # Display results\n        st.subheader(\"🎯 Prediction Results\")\n        \n        col1, col2, col3 = st.columns(3)\n        \n        with col1:\n            st.markdown(f\"\"\"\n            <div class=\"prediction-box {risk_class}\">\n                <h3 style=\"margin: 0; color: {risk_color};\">Risk Level: {risk_level}</h3>\n                <p style=\"margin: 10px 0 0 0; font-size: 1.2em;\">\n                    Infection Probability: <strong>{risk_prob:.1%}</strong>\n                </p>\n            </div>\n            \"\"\", unsafe_allow_html=True)\n        \n        with col2:\n            # Risk gauge chart\n            fig_gauge = go.Figure(go.Indicator(\n                mode = \"gauge+number+delta\",\n                value = risk_prob * 100,\n                domain = {'x': [0, 1], 'y': [0, 1]},\n                title = {'text': \"Risk Score\"},\n                delta = {'reference': 50},\n                gauge = {\n                    'axis': {'range': [None, 100]},\n                    'bar': {'color': risk_color},\n                    'steps': [\n                        {'range': [0, 40], 'color': \"lightgreen\"},\n                        {'range': [40, 70], 'color': \"yellow\"},\n                        {'range': [70, 100], 'color': \"lightcoral\"}\n                    ],\n                    'threshold': {\n                        'line': {'color': \"red\", 'width': 4},\n                        'thickness': 0.75,\n                        'value': 90\n                    }\n                }\n            ))\n            fig_gauge.update_layout(height=250)\n            st.plotly_chart(fig_gauge, use_container_width=True)\n        \n        with col3:\n            st.markdown(f\"\"\"\n            <div class=\"metric-card\">\n                <h4>Confidence Interval</h4>\n                <p>{risk_prob-0.1:.1%} - {risk_prob+0.1:.1%}</p>\n                <h4>Recommendation</h4>\n                <p>{\"Immediate medical attention\" if risk_level == \"High\" else \n                    \"Regular monitoring\" if risk_level == \"Medium\" else \n                    \"Routine screening\"}</p>\n            </div>\n            \"\"\", unsafe_allow_html=True)\n        \n        # Feature importance for this prediction\n        if hasattr(self.ml_pipeline, 'best_model') and self.ml_pipeline.best_model is not None:\n            st.subheader(\"🔍 Key Contributing Factors\")\n            \n            try:\n                # Get global feature importances\n                if hasattr(self.ml_pipeline.best_model, 'feature_importances_'):\n                    feature_names = self.ml_pipeline.preprocessor.get_feature_names_out()\n                    importances = self.ml_pipeline.best_model.feature_importances_\n                    \n                    # Get top 10 most important features overall\n                    feature_importance_pairs = list(zip(feature_names, importances))\n                    feature_importance_pairs.sort(key=lambda x: x[1], reverse=True)\n                    top_features = feature_importance_pairs[:10]\n                    \n                    # Clean feature names for display\n                    clean_features = []\n                    for feat, imp in top_features:\n                        # Remove prefix like 'num__' or 'cat__'\n                        clean_name = feat.split('__')[-1] if '__' in feat else feat\n                        clean_features.append((clean_name.replace('_', ' ').title(), imp))\n                    \n                    # Create dataframe for plotting\n                    importance_df = pd.DataFrame(clean_features, columns=['Feature', 'Importance'])\n                    \n                    fig_importance = px.bar(\n                        importance_df, \n                        x='Importance', \n                        y='Feature',\n                        orientation='h',\n                        title='Top 10 Most Important Clinical Factors',\n                        color='Importance',\n                        color_continuous_scale='viridis'\n                    )\n                    fig_importance.update_layout(yaxis={'categoryorder':'total ascending'})\n                    st.plotly_chart(fig_importance, use_container_width=True)\n                    \n                    # Display key patient-specific factors\n                    st.markdown(\"**Key Patient Factors in This Case:**\")\n                    risk_factors = []\n                    if patient_data.get('Gastritis_History', 0) == 1:\n                        risk_factors.append(\"• Previous gastritis history\")\n                    if patient_data.get('Ulcer_History', 0) == 1:\n                        risk_factors.append(\"• Previous ulcer disease\")\n                    if patient_data.get('Family_Pylori_History', 0) == 1:\n                        risk_factors.append(\"• Family history of H. pylori\")\n                    if patient_data.get('Smoking', 0) > 0:\n                        risk_factors.append(\"• Current/past smoking\")\n                    if patient_data.get('BMI', 25) > 30:\n                        risk_factors.append(\"• Elevated BMI\")\n                    \n                    if risk_factors:\n                        st.markdown(\"\\n\".join(risk_factors))\n                    else:\n                        st.markdown(\"• No major risk factors identified in patient history\")\n                \n            except Exception as e:\n                st.info(\"Feature analysis currently unavailable\")\n        \n        # Clinical Treatment Recommendation\n        st.subheader(\"💊 Clinical Decision Support\")\n        \n        # Generate simple, evidence-based clinical guidance\n        def get_clinical_recommendation(risk_level, risk_prob, patient_data):\n            \"\"\"Generate concise clinical recommendations for doctors\"\"\"\n            \n            recommendations = {\n                'High': {\n                    'action': '**Immediate action required:** Order confirmatory testing (stool antigen or urea breath test) and initiate empirical triple therapy pending results.',\n                    'treatment': '**Treatment:** PPI-based triple therapy (PPI + Amoxicillin + Clarithromycin) for 14 days, or quadruple therapy if clarithromycin resistance suspected.'\n                },\n                'Medium': {\n                    'action': '**Clinical evaluation recommended:** Perform diagnostic testing (stool antigen or urea breath test) to confirm infection status.',\n                    'treatment': '**Treatment:** If confirmed positive, initiate standard triple therapy (PPI + Amoxicillin + Clarithromycin) for 14 days with 4-week post-treatment follow-up.'\n                },\n                'Low': {\n                    'action': '**Routine monitoring sufficient:** Consider testing only if patient develops dyspeptic symptoms or has additional risk factors.',\n                    'treatment': '**Management:** Watchful waiting with patient education on hygiene practices and dietary modifications. Annual screening if family history present.'\n                }\n            }\n            \n            rec = recommendations[risk_level]\n            \n            # Add risk factor context\n            risk_factors = []\n            if patient_data.get('Gastritis_History', 0) == 1:\n                risk_factors.append(\"previous gastritis\")\n            if patient_data.get('Ulcer_History', 0) == 1:\n                risk_factors.append(\"ulcer history\")\n            if patient_data.get('Family_Pylori_History', 0) == 1:\n                risk_factors.append(\"family H. pylori history\")\n            \n            context = f\"**Risk Factors Present:** {', '.join(risk_factors)}\" if risk_factors else \"**Risk Factors:** None identified\"\n            \n            return rec['action'], rec['treatment'], context\n        \n        action, treatment, context = get_clinical_recommendation(risk_level, risk_prob, patient_data)\n        \n        st.markdown(f\"\"\"\n        <div style=\"background-color: #f0f8ff; padding: 20px; border-radius: 10px; border-left: 5px solid {risk_color};\">\n            <h4 style=\"margin-top: 0;\">Evidence-Based Clinical Guidance</h4>\n            <p style=\"font-size: 1.05em; line-height: 1.6;\">\n                {action}\n            </p>\n            <p style=\"font-size: 1.05em; line-height: 1.6;\">\n                {treatment}\n            </p>\n            <p style=\"font-size: 0.95em; color: #666; margin-bottom: 0;\">\n                {context}\n            </p>\n        </div>\n        \"\"\", unsafe_allow_html=True)\n        \n        # AI Treatment Recommendations (automatic if configured)\n        ai_configured = st.session_state.get('openai_configured', False) or st.session_state.get('gemini_configured', False)\n        \n        if ai_configured:\n            st.markdown(\"---\")\n            st.subheader(\"🤖 AI-Powered Personalized Treatment Recommendations\")\n            \n            with st.spinner(\"Generating AI-powered personalized recommendations...\"):\n                try:\n                    # Get API keys from session state\n                    openai_key = st.session_state.get('custom_openai_key', '')\n                    gemini_key = st.session_state.get('custom_gemini_key', '')\n                    preferred_ai = st.session_state.get('preferred_ai', 'auto')\n                    \n                    # Initialize clients with session state keys\n                    import google.genai as genai\n                    from openai import OpenAI\n                    \n                    # Build comprehensive patient profile for AI\n                    smoking_map = {0: \"None\", 1: \"1-5/day\", 2: \"6-10/day\", 3: \">10/day\"}\n                    alcohol_map = {0: \"None\", 1: \"Monthly\", 2: \"Weekly\", 3: \"3+/Weekly\"}\n                    handwash_map = {0: \"Rarely\", 1: \"Now & then\", 2: \"Frequent\", 3: \"Daily\"}\n                    food_map = {0: \"Rare\", 1: \"Now & then\", 2: \"Frequent\", 3: \"Daily\"}\n                    \n                    patient_profile = f\"\"\"\n**PATIENT PROFILE:**\n\nDemographics:\n- Age: {patient_data.get('Age')} years\n- Sex: {'Male' if patient_data.get('Sex') == 1 else 'Female'}\n- BMI: {patient_data.get('BMI', 'N/A')} kg/m²\n- Marital Status: {'Married' if patient_data.get('Marital_Status') == 1 else 'Single'}\n\nClinical History:\n- Previous Gastritis: {'Yes' if patient_data.get('Gastritis_History') == 1 else 'No'}\n- Previous Ulcer Disease: {'Yes' if patient_data.get('Ulcer_History') == 1 else 'No'}\n- Family H. Pylori History: {'Yes' if patient_data.get('Family_Pylori_History') == 1 else 'No'}\n- Family Gastritis History: {'Yes' if patient_data.get('Family_Gastritis_History') == 1 else 'No'}\n\nLaboratory Values:\n- Albumin: {patient_data.get('Albumin', 'N/A')} g/L\n- WBC Count: {patient_data.get('WBC_Count', 'N/A')} ×10⁹/L\n- Hemoglobin: {patient_data.get('Hemoglobin', 'N/A')} g/L\n- RBC Count: {patient_data.get('RBC_Count', 'N/A')} ×10¹²/L\n\nLifestyle Factors:\n- Smoking: {smoking_map.get(patient_data.get('Smoking', 0), 'None')}\n- Alcohol: {alcohol_map.get(patient_data.get('Alcohol', 0), 'None')}\n- Handwashing: {handwash_map.get(patient_data.get('Handwashing', 3), 'Daily')}\n- Pickled Food Consumption: {food_map.get(patient_data.get('Pickled_Food', 0), 'Rare')}\n- Tableware Sharing: {food_map.get(patient_data.get('Tableware_Sharing', 0), 'Rare')}\n\nEndoscopic Findings:\n- Gastric Nodularity: {'Yes' if patient_data.get('Nodularity') == 1 else 'No' if patient_data.get('Nodularity') == 0 else 'Not Available'}\n- Gastric Redness: {'Yes' if patient_data.get('Gastric_Redness') == 1 else 'No' if patient_data.get('Gastric_Redness') == 0 else 'Not Available'}\n\n**RISK ASSESSMENT:**\n- H. Pylori Infection Probability: {risk_prob:.1%}\n- Risk Level: {risk_level}\n\"\"\"\n                    \n                    prompt = f\"\"\"You are an experienced gastroenterologist providing personalized, evidence-based treatment recommendations for H. pylori infection.\n\n{patient_profile}\n\nBased on this comprehensive patient profile, provide detailed, personalized treatment recommendations including:\n\n1. **Clinical Assessment**: Interpret the risk level and key patient-specific factors\n2. **Diagnostic Testing Strategy**: Specific tests recommended for this patient\n3. **Treatment Plan**: \n   - First-line therapy with dosages and duration\n   - Consider patient-specific factors (age, BMI, lifestyle)\n   - Alternative options if contraindications exist\n4. **Lifestyle Modifications**: Personalized advice based on patient's current habits\n5. **Follow-up Protocol**: Specific timeline and monitoring plan\n6. **Patient Education**: Key points to discuss with this patient\n\nFocus on personalization based on the patient's specific risk factors, lab values, and lifestyle. Be specific and actionable for clinical decision-making.\"\"\"\n\n                    ai_recommendation = None\n                    \n                    if preferred_ai == \"OpenAI GPT\" and openai_key:\n                        client = OpenAI(api_key=openai_key)\n                        response = client.chat.completions.create(\n                            model=\"gpt-4o-mini\",\n                            messages=[{\n                                \"role\": \"system\",\n                                \"content\": \"You are an experienced gastroenterologist specializing in H. pylori management. Provide evidence-based, personalized treatment recommendations following current clinical guidelines.\"\n                            }, {\n                                \"role\": \"user\", \n                                \"content\": prompt\n                            }],\n                            max_completion_tokens=1500\n                        )\n                        ai_recommendation = response.choices[0].message.content\n                    elif preferred_ai == \"Google Gemini\" and gemini_key:\n                        client = genai.Client(api_key=gemini_key)\n                        response = client.models.generate_content(\n                            model=\"gemini-2.0-flash-exp\",\n                            contents=prompt\n                        )\n                        ai_recommendation = response.text\n                    \n                    if ai_recommendation:\n                        st.markdown(f\"*Generated using {preferred_ai}*\")\n                        st.markdown(ai_recommendation)\n                        \n                        # Add disclaimer\n                        st.markdown(\"---\")\n                        st.warning(\"\"\"\n                        **⚠️ IMPORTANT DISCLAIMER:**  \n                        This AI-generated recommendation is for educational purposes and clinical decision support only. \n                        Always use professional medical judgment and consider individual patient circumstances. \n                        This should not replace comprehensive clinical evaluation and consultation.\n                        \"\"\")\n                    else:\n                        st.warning(\"⚠️ Please configure API key in the sidebar to get AI recommendations\")\n                        \n                except Exception as e:\n                    st.error(f\"❌ AI service error: {str(e)}\")\n                    st.info(\"Please verify your API key is valid and has sufficient credits.\")\n        else:\n            st.info(\"💡 **Optional:** Configure OpenAI or Gemini API keys in the sidebar for AI-powered personalized treatment recommendations\")\n    \n    def render_model_performance(self):\n        \"\"\"Render model performance metrics\"\"\"\n        st.subheader(\"📊 Model Performance Dashboard\")\n        \n        if self.ml_pipeline is None:\n            st.warning(\"No model loaded. Please contact your system administrator.\")\n            return\n            \n        if not hasattr(self.ml_pipeline, 'model_results') or not self.ml_pipeline.model_results:\n            st.warning(\"Model performance data not available. Model loaded successfully but metrics are missing.\")\n            st.info(\"The model can still make predictions. Go to the Patient Prediction page to use it.\")\n            return\n        \n        results = self.ml_pipeline.model_results\n        \n        # Display metrics table\n        st.write(\"### Model Comparison\")\n        metrics_df = pd.DataFrame(results).T\n        st.dataframe(metrics_df, use_container_width=True)\n        \n        # Best model visualization\n        best_model_name = max(results.keys(), key=lambda x: results[x]['roc_auc'])\n        st.write(f\"### Best Model: {best_model_name}\")\n        \n        best_metrics = results[best_model_name]\n        \n        col1, col2, col3, col4 = st.columns(4)\n        \n        with col1:\n            st.metric(\"Accuracy\", f\"{best_metrics['accuracy']:.3f}\")\n        with col2:\n            st.metric(\"ROC-AUC\", f\"{best_metrics['roc_auc']:.3f}\")\n        with col3:\n            st.metric(\"Precision\", f\"{best_metrics['precision']:.3f}\")\n        with col4:\n            st.metric(\"Recall\", f\"{best_metrics['recall']:.3f}\")\n        \n        # ROC Curve comparison\n        if hasattr(self.ml_pipeline, 'roc_curves'):\n            st.write(\"### ROC Curve Comparison\")\n            fig_roc = go.Figure()\n            \n            for model_name, (fpr, tpr, auc) in self.ml_pipeline.roc_curves.items():\n                fig_roc.add_trace(go.Scatter(\n                    x=fpr, y=tpr,\n                    mode='lines',\n                    name=f'{model_name} (AUC = {auc:.3f})'\n                ))\n            \n            fig_roc.add_trace(go.Scatter(\n                x=[0, 1], y=[0, 1],\n                mode='lines',\n                name='Random',\n                line=dict(dash='dash', color='gray')\n            ))\n            \n            fig_roc.update_layout(\n                title='ROC Curves Comparison',\n                xaxis_title='False Positive Rate',\n                yaxis_title='True Positive Rate',\n                width=800, height=500\n            )\n            st.plotly_chart(fig_roc, use_container_width=True)\n        \n        # Confusion Matrix for best model\n        if hasattr(self.ml_pipeline, 'confusion_matrices'):\n            st.write(\"### Confusion Matrix - Best Model\")\n            cm = self.ml_pipeline.confusion_matrices.get(best_model_name)\n            if cm is not None:\n                fig_cm = px.imshow(\n                    cm, \n                    labels=dict(x=\"Predicted\", y=\"Actual\", color=\"Count\"),\n                    x=['No Infection', 'Infection'],\n                    y=['No Infection', 'Infection'],\n                    text_auto=True,\n                    aspect=\"auto\",\n                    title=f\"Confusion Matrix - {best_model_name}\"\n                )\n                st.plotly_chart(fig_cm, use_container_width=True)\n        \n        # Feature Importance\n        if hasattr(self.ml_pipeline, 'feature_importances') and self.ml_pipeline.feature_importances:\n            st.write(\"### Feature Importance - Best Model\")\n            \n            # Get feature importances for best model\n            importances = self.ml_pipeline.feature_importances.get(best_model_name)\n            \n            if importances is not None:\n                # Get feature names\n                try:\n                    feature_names = self.ml_pipeline.preprocessor.get_feature_names_out()\n                    \n                    # Create dataframe and sort by importance\n                    feat_df = pd.DataFrame({\n                        'Feature': feature_names,\n                        'Importance': importances\n                    }).sort_values('Importance', ascending=False).head(15)\n                    \n                    # Create bar chart\n                    fig_feat = go.Figure(data=[\n                        go.Bar(\n                            x=feat_df['Importance'],\n                            y=feat_df['Feature'],\n                            orientation='h',\n                            marker=dict(color='#1f77b4')\n                        )\n                    ])\n                    \n                    fig_feat.update_layout(\n                        title=f'Top 15 Most Important Features - {best_model_name}',\n                        xaxis_title='Importance',\n                        yaxis_title='Feature',\n                        height=500,\n                        yaxis=dict(autorange='reversed')\n                    )\n                    \n                    st.plotly_chart(fig_feat, use_container_width=True)\n                except Exception as e:\n                    st.info(f\"Feature importance visualization not available: {e}\")\n    \n    def run(self):\n        \"\"\"Main application runner\"\"\"\n        st.markdown('<h1 class=\"main-header\">🔬 <span style=\"color: #1f77b4; font-weight: bold;\">PyloScan</span> - H. Pylori Infection Prediction System</h1>', \n                   unsafe_allow_html=True)\n        \n        # Initialize session state\n        if 'model_loaded' not in st.session_state:\n            st.session_state.model_loaded = False\n        \n        # Load model on startup\n        if not st.session_state.model_loaded:\n            if self.load_or_train_model():\n                st.session_state.model_loaded = True\n                st.sidebar.success(\"✅ Model loaded successfully!\")\n            else:\n                st.sidebar.error(\"❌ No trained model found. Please contact your system administrator.\")\n        \n        # Render sidebar navigation\n        selected_page = self.render_sidebar()\n        \n        # Render selected page\n        if selected_page == \"Patient Prediction\":\n            st.header(\"👤 Patient Risk Assessment\")\n            st.write(\"Enter patient information below to predict H. Pylori infection risk.\")\n            \n            patient_data = self.render_patient_input_form()\n            \n            if st.button(\"🎯 Predict H. Pylori Risk\", type=\"primary\", use_container_width=True):\n                self.predict_and_display_results(patient_data)\n                \n        elif selected_page == \"Model Performance\":\n            self.render_model_performance()\n        \n        # Footer\n        st.markdown(\"---\")\n        st.markdown(\"\"\"\n        <div style=\"text-align: center; color: #666; font-size: 0.9em;\">\n            <span style=\"color: #1f77b4; font-weight: bold;\">PyloScan</span> - H. Pylori Infection Prediction System | \n            Clinical Decision Support Tool | Powered by A1Intercept Technologies\n        </div>\n        <div style=\"text-align: center; color: #999; font-size: 0.8em; margin-top: 0.5rem;\">\n            ⚠️ For clinical use only. This tool assists healthcare professionals in risk assessment.\n        </div>\n        \"\"\", unsafe_allow_html=True)\n\nif __name__ == \"__main__\":\n    app = HPyloriApp()\n    app.run()\n","size_bytes":36045},"replit.md":{"content":"# H. Pylori Infection Prediction System\n\n## Project Overview\n\nA clinical decision support tool for predicting H. Pylori infection risk using Machine Learning and AI-powered treatment recommendations.\n\n## Current Implementation Status\n\n### ✅ Completed Features\n\n1. **Synthetic Data Generation** (One-Time Setup)\n   - Generated 1,000 realistic patient records\n   - 26 clinical features across demographics, history, labs, and lifestyle\n   - Saved to `data/training_data.csv`\n\n2. **Machine Learning Pipeline**\n   - Trained 5 classification models (Logistic Regression, Random Forest, XGBoost, Gradient Boosting, SVM)\n   - Best model: Random Forest with 85.2% ROC-AUC\n   - Feature engineering: 35 engineered features\n   - SMOTE balancing for class imbalance\n   - Saved to `models/` directory\n\n3. **Streamlit Web Application**\n   - Patient prediction interface with comprehensive input forms\n   - Risk stratification (Low/Medium/High)\n   - Model performance dashboard\n   - AI-powered treatment recommendations\n   - API key configuration via UI\n\n4. **AI Integration**\n   - Support for OpenAI GPT-5 and Google Gemini 2.5 Pro\n   - Evidence-based treatment recommendations\n   - Following ACG, AGA, and Maastricht VI guidelines\n   - Configurable via AI Settings page\n\n## Application Structure\n\n### Pages\n1. **Patient Prediction** (Main): Enter patient data and get risk predictions\n2. **Model Performance**: View model metrics, ROC curves, confusion matrices\n3. **AI Settings**: Configure API keys for AI recommendations\n\n### Key Files\n- `app.py` - Main Streamlit application\n- `data_generator.py` - Synthetic data generation\n- `ml_pipeline.py` - ML training and prediction pipeline\n- `ai_recommendations.py` - AI treatment recommendations\n- `model_utils.py` - Visualization utilities\n- `setup_model.py` - One-time setup script\n\n## Model Performance\n\n**Random Forest Classifier:**\n- ROC-AUC: 85.2%\n- Accuracy: 78.5%\n- Precision: 71.2%\n- Recall: 66.2%\n- Cross-validation ROC-AUC: 90.5% (± 4.1%)\n\n## Usage Instructions\n\n### For End Users (Doctors/Clinicians)\n1. Open the application (already running on port 5000)\n2. Go to **AI Settings** to configure API keys (if needed)\n3. Navigate to **Patient Prediction** page\n4. Enter patient information in the form\n5. Click \"Predict H. Pylori Risk\"\n6. View risk probability and generate AI treatment recommendations\n\n### For Administrators\n\n**Initial Setup (Already Done):**\n```bash\npython setup_model.py\n```\n\n**Running the Application:**\n```bash\nstreamlit run app.py --server.port 5000\n```\n\n## Data Flow\n\n1. **Input**: Patient demographics, clinical history, lab values, lifestyle factors\n2. **Processing**: Feature engineering (35 features), standardization\n3. **Prediction**: Random Forest classifier outputs probability\n4. **Risk Categorization**: \n   - Low: < 40%\n   - Medium: 40-70%\n   - High: ≥ 70%\n5. **AI Recommendations**: Personalized treatment plan based on risk and patient profile\n\n## API Keys Required\n\nFor AI treatment recommendations, configure one of:\n- **OpenAI API Key**: Get from https://platform.openai.com/api-keys\n- **Gemini API Key**: Get from https://aistudio.google.com/apikey\n\nKeys can be configured via:\n- UI: AI Settings page (session-based)\n- Environment variables: `OPENAI_API_KEY` or `GEMINI_API_KEY`\n\n## Important Notes\n\n### Clinical Use\n- ⚠️ For clinical decision support only\n- Not a replacement for professional medical judgment\n- Assists healthcare professionals in risk assessment\n\n### Data & Privacy\n- No patient data stored permanently\n- Model trained on synthetic data\n- API keys stored only in session (not persisted)\n\n### Model Limitations\n- Trained on synthetic data (simulates real patterns)\n- Performance may vary with actual patient populations\n- Regular validation with real data recommended\n\n## Recent Changes (October 2025)\n\n1. **Simplified Application**\n   - Removed data generation UI (one-time setup only)\n   - Removed model training UI (pre-trained model)\n   - Focused on patient prediction workflow\n\n2. **Enhanced AI Settings**\n   - Added UI for API key configuration\n   - Test connection feature\n   - Support for both OpenAI and Gemini\n\n3. **Model Optimization**\n   - Selected Random Forest as best performer\n   - Saved trained model for production use\n   - No retraining needed during app usage\n\n## Technology Stack\n\n- **Frontend**: Streamlit\n- **ML Framework**: Scikit-learn, XGBoost\n- **Data Processing**: Pandas, NumPy\n- **Visualization**: Plotly\n- **AI Services**: OpenAI GPT-5, Google Gemini 2.5 Pro\n- **Data Balancing**: Imbalanced-learn (SMOTE)\n\n## Future Enhancements (Planned)\n\n1. Batch prediction via CSV upload\n2. Model retraining pipeline with new data\n3. Patient history tracking\n4. PDF report export\n5. Real-time performance monitoring\n","size_bytes":4747},"ml_pipeline.py":{"content":"import pandas as pd\nimport numpy as np\nfrom sklearn.model_selection import train_test_split, cross_val_score, StratifiedKFold\nfrom sklearn.preprocessing import StandardScaler, LabelEncoder\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier\nfrom sklearn.svm import SVC\nfrom sklearn.metrics import (\n    accuracy_score, precision_score, recall_score, f1_score, \n    roc_auc_score, confusion_matrix, classification_report, roc_curve\n)\nfrom sklearn.feature_selection import SelectKBest, chi2, f_classif\nfrom imblearn.over_sampling import SMOTE\nfrom imblearn.pipeline import Pipeline as ImbPipeline\nimport xgboost as xgb\nimport joblib\nimport warnings\nwarnings.filterwarnings('ignore')\n\nclass MLPipeline:\n    \"\"\"\n    Comprehensive ML Pipeline for H. Pylori infection prediction\n    \"\"\"\n    \n    def __init__(self):\n        self.models = {}\n        self.preprocessor = None\n        self.best_model = None\n        self.best_model_name = None\n        self.model_results = {}\n        self.feature_importances = {}\n        self.roc_curves = {}\n        self.confusion_matrices = {}\n        \n    def create_preprocessor(self, X):\n        \"\"\"\n        Create preprocessing pipeline for features\n        \"\"\"\n        # Identify numeric and categorical columns\n        numeric_features = X.select_dtypes(include=['int64', 'float64']).columns.tolist()\n        \n        # Handle missing values (-1) in endoscopy features\n        endoscopy_features = ['Nodularity', 'Gastric_Redness']\n        \n        # Numeric preprocessing pipeline\n        numeric_transformer = Pipeline(steps=[\n            ('imputer', SimpleImputer(strategy='median')),\n            ('scaler', StandardScaler())\n        ])\n        \n        # Create column transformer\n        self.preprocessor = ColumnTransformer(\n            transformers=[\n                ('num', numeric_transformer, numeric_features)\n            ],\n            remainder='passthrough'\n        )\n        \n        return self.preprocessor\n    \n    def engineer_features(self, df):\n        \"\"\"\n        Create derived features and feature interactions\n        \"\"\"\n        df_engineered = df.copy()\n        \n        # Age groups\n        df_engineered['Age_Group'] = pd.cut(\n            df_engineered['Age'], \n            bins=[0, 30, 45, 60, 100], \n            labels=[0, 1, 2, 3]\n        ).astype(int)\n        \n        # BMI categories\n        bmi_conditions = [\n            (df_engineered['BMI'] < 18.5),\n            (df_engineered['BMI'] >= 18.5) & (df_engineered['BMI'] < 25),\n            (df_engineered['BMI'] >= 25) & (df_engineered['BMI'] < 30),\n            (df_engineered['BMI'] >= 30)\n        ]\n        bmi_choices = [0, 1, 2, 3]  # Underweight, Normal, Overweight, Obese\n        df_engineered['BMI_Category'] = np.select(bmi_conditions, bmi_choices)\n        \n        # Lifestyle risk score\n        df_engineered['Lifestyle_Risk'] = (\n            df_engineered['Smoking'] * 0.3 +\n            df_engineered['Alcohol'] * 0.2 +\n            df_engineered['Pickled_Food'] * 0.2 +\n            (3 - df_engineered['Handwashing']) * 0.3  # Reverse handwashing (less = more risk)\n        )\n        \n        # Family risk score\n        df_engineered['Family_Risk'] = (\n            df_engineered['Family_Pylori_History'] * 0.6 +\n            df_engineered['Family_Gastritis_History'] * 0.4\n        )\n        \n        # Clinical history score\n        df_engineered['Clinical_History_Score'] = (\n            df_engineered['Gastritis_History'] * 0.5 +\n            df_engineered['Ulcer_History'] * 0.5\n        )\n        \n        # Blood parameter ratios (common clinical indicators)\n        df_engineered['Neutrophil_Lymphocyte_Ratio'] = (\n            df_engineered['Neutrophil_Count'] / (df_engineered['Lymphocyte_Count'] + 0.1)\n        )\n        \n        # Socioeconomic indicator\n        df_engineered['Socioeconomic_Score'] = (\n            df_engineered['Education'] * 0.4 +\n            (3 - df_engineered['Residence']) * 0.3 +  # Urban = higher score\n            df_engineered['Water_Source'] * 0.3\n        )\n        \n        # Interaction terms\n        df_engineered['Age_BMI'] = df_engineered['Age'] * df_engineered['BMI'] / 100\n        df_engineered['Family_Size_Sharing'] = (\n            df_engineered['Family_Size'] * df_engineered['Tableware_Sharing'] / 10\n        )\n        \n        # Handle missing endoscopy data\n        df_engineered['Has_Endoscopy'] = (\n            (df_engineered['Nodularity'] != -1) & (df_engineered['Gastric_Redness'] != -1)\n        ).astype(int)\n        \n        # Convert missing endoscopy values to 0 for modeling\n        df_engineered['Nodularity'] = df_engineered['Nodularity'].replace(-1, 0)\n        df_engineered['Gastric_Redness'] = df_engineered['Gastric_Redness'].replace(-1, 0)\n        \n        return df_engineered\n    \n    def setup_models(self):\n        \"\"\"\n        Initialize all models to be evaluated\n        \"\"\"\n        self.models = {\n            'Logistic_Regression': LogisticRegression(\n                random_state=42, \n                max_iter=1000,\n                class_weight='balanced'\n            ),\n            'Random_Forest': RandomForestClassifier(\n                n_estimators=100,\n                random_state=42,\n                class_weight='balanced',\n                max_depth=10,\n                min_samples_split=5\n            ),\n            'XGBoost': xgb.XGBClassifier(\n                random_state=42,\n                eval_metric='logloss',\n                scale_pos_weight=1,\n                max_depth=6,\n                learning_rate=0.1\n            ),\n            'Gradient_Boosting': GradientBoostingClassifier(\n                random_state=42,\n                n_estimators=100,\n                learning_rate=0.1,\n                max_depth=5\n            ),\n            'SVM': SVC(\n                random_state=42,\n                probability=True,\n                class_weight='balanced',\n                kernel='rbf'\n            )\n        }\n    \n    def evaluate_model(self, model, X_train, X_test, y_train, y_test):\n        \"\"\"\n        Evaluate a single model and return metrics\n        \"\"\"\n        # Train model\n        model.fit(X_train, y_train)\n        \n        # Predictions\n        y_pred = model.predict(X_test)\n        y_pred_proba = model.predict_proba(X_test)[:, 1]\n        \n        # Calculate metrics\n        metrics = {\n            'accuracy': accuracy_score(y_test, y_pred),\n            'precision': precision_score(y_test, y_pred, zero_division=0),\n            'recall': recall_score(y_test, y_pred, zero_division=0),\n            'f1': f1_score(y_test, y_pred, zero_division=0),\n            'roc_auc': roc_auc_score(y_test, y_pred_proba)\n        }\n        \n        # ROC curve data\n        fpr, tpr, _ = roc_curve(y_test, y_pred_proba)\n        \n        # Confusion matrix\n        cm = confusion_matrix(y_test, y_pred)\n        \n        return metrics, (fpr, tpr, metrics['roc_auc']), cm\n    \n    def train_models(self, data):\n        \"\"\"\n        Train and evaluate all models\n        \"\"\"\n        # Feature engineering\n        print(\"Performing feature engineering...\")\n        data_engineered = self.engineer_features(data)\n        \n        # Separate features and target\n        X = data_engineered.drop('H_Pylori_Infection', axis=1)\n        y = data_engineered['H_Pylori_Infection']\n        \n        print(f\"Dataset shape after feature engineering: {X.shape}\")\n        print(f\"Target distribution: {y.value_counts().to_dict()}\")\n        \n        # Create preprocessor\n        self.create_preprocessor(X)\n        \n        # Split data\n        X_train, X_test, y_train, y_test = train_test_split(\n            X, y, test_size=0.2, random_state=42, stratify=y\n        )\n        \n        # Preprocess data\n        X_train_processed = self.preprocessor.fit_transform(X_train)\n        X_test_processed = self.preprocessor.transform(X_test)\n        \n        # Apply SMOTE for class balancing\n        smote = SMOTE(random_state=42)\n        X_train_balanced, y_train_balanced = smote.fit_resample(X_train_processed, y_train)\n        \n        print(f\"After SMOTE - Training set shape: {X_train_balanced.shape}\")\n        print(f\"After SMOTE - Target distribution: {np.bincount(y_train_balanced)}\")\n        \n        # Setup models\n        self.setup_models()\n        \n        # Train and evaluate each model\n        best_score = 0\n        \n        for name, model in self.models.items():\n            print(f\"\\nTraining {name}...\")\n            \n            try:\n                # Evaluate model\n                metrics, roc_data, cm = self.evaluate_model(\n                    model, X_train_balanced, X_test_processed, y_train_balanced, y_test\n                )\n                \n                # Store results\n                self.model_results[name] = metrics\n                self.roc_curves[name] = roc_data\n                self.confusion_matrices[name] = cm\n                \n                # Check if this is the best model\n                if metrics['roc_auc'] > best_score:\n                    best_score = metrics['roc_auc']\n                    self.best_model = model\n                    self.best_model_name = name\n                \n                # Store feature importance if available\n                if hasattr(model, 'feature_importances_'):\n                    self.feature_importances[name] = model.feature_importances_\n                elif hasattr(model, 'coef_'):\n                    self.feature_importances[name] = np.abs(model.coef_[0])\n                \n                print(f\"{name} - ROC AUC: {metrics['roc_auc']:.3f}, Accuracy: {metrics['accuracy']:.3f}\")\n                \n            except Exception as e:\n                print(f\"Error training {name}: {str(e)}\")\n                continue\n        \n        print(f\"\\nBest model: {self.best_model_name} with ROC AUC: {best_score:.3f}\")\n        \n        # Perform cross-validation on best model\n        print(\"\\nPerforming cross-validation on best model...\")\n        cv_scores = cross_val_score(\n            self.best_model, X_train_balanced, y_train_balanced, \n            cv=StratifiedKFold(n_splits=5, shuffle=True, random_state=42),\n            scoring='roc_auc'\n        )\n        print(f\"Cross-validation ROC AUC: {cv_scores.mean():.3f} (+/- {cv_scores.std() * 2:.3f})\")\n        \n        return self.model_results\n    \n    def predict(self, X):\n        \"\"\"\n        Make predictions using the best model\n        \"\"\"\n        if self.best_model is None:\n            raise ValueError(\"No model has been trained yet!\")\n        \n        # Feature engineering\n        X_engineered = self.engineer_features(X)\n        \n        # Remove target if present\n        if 'H_Pylori_Infection' in X_engineered.columns:\n            X_engineered = X_engineered.drop('H_Pylori_Infection', axis=1)\n        \n        # Preprocess\n        X_processed = self.preprocessor.transform(X_engineered)\n        \n        return self.best_model.predict(X_processed)\n    \n    def predict_proba(self, X):\n        \"\"\"\n        Get prediction probabilities using the best model\n        \"\"\"\n        if self.best_model is None:\n            raise ValueError(\"No model has been trained yet!\")\n        \n        # Feature engineering\n        X_engineered = self.engineer_features(X)\n        \n        # Remove target if present\n        if 'H_Pylori_Infection' in X_engineered.columns:\n            X_engineered = X_engineered.drop('H_Pylori_Infection', axis=1)\n        \n        # Preprocess\n        X_processed = self.preprocessor.transform(X_engineered)\n        \n        return self.best_model.predict_proba(X_processed)\n    \n    def get_feature_importance(self, top_n=20):\n        \"\"\"\n        Get feature importance from the best model\n        \"\"\"\n        if self.best_model_name not in self.feature_importances:\n            return None\n        \n        feature_names = self.preprocessor.get_feature_names_out()\n        importances = self.feature_importances[self.best_model_name]\n        \n        importance_df = pd.DataFrame({\n            'feature': feature_names,\n            'importance': importances\n        }).sort_values('importance', ascending=False)\n        \n        return importance_df.head(top_n)\n    \n    def save_model(self, model_path, preprocessor_path):\n        \"\"\"\n        Save the trained model and preprocessor\n        \"\"\"\n        if self.best_model is None:\n            raise ValueError(\"No model to save!\")\n        \n        joblib.dump(self.best_model, model_path)\n        joblib.dump(self.preprocessor, preprocessor_path)\n        \n        # Save additional metadata\n        metadata = {\n            'best_model_name': self.best_model_name,\n            'model_results': self.model_results,\n            'feature_importances': self.feature_importances,\n            'roc_curves': self.roc_curves,\n            'confusion_matrices': self.confusion_matrices\n        }\n        joblib.dump(metadata, model_path.replace('.joblib', '_metadata.joblib'))\n    \n    def load_model(self, model_path, preprocessor_path):\n        \"\"\"\n        Load a trained model and preprocessor\n        \"\"\"\n        self.best_model = joblib.load(model_path)\n        self.preprocessor = joblib.load(preprocessor_path)\n        \n        # Load metadata if available\n        try:\n            metadata_path = model_path.replace('.joblib', '_metadata.joblib')\n            metadata = joblib.load(metadata_path)\n            self.best_model_name = metadata.get('best_model_name', 'Unknown')\n            self.model_results = metadata.get('model_results', {})\n            self.feature_importances = metadata.get('feature_importances', {})\n            self.roc_curves = metadata.get('roc_curves', {})\n            self.confusion_matrices = metadata.get('confusion_matrices', {})\n            print(f\"✓ Loaded model metadata: {self.best_model_name}\")\n            print(f\"✓ Model results available: {len(self.model_results)} models\")\n            print(f\"✓ ROC curves available: {len(self.roc_curves)} models\")\n        except Exception as e:\n            print(f\"Warning: Could not load model metadata: {e}\")\n            self.best_model_name = 'Unknown'\n            self.model_results = {}\n            self.feature_importances = {}\n    \n    def generate_classification_report(self, X_test, y_test):\n        \"\"\"\n        Generate detailed classification report\n        \"\"\"\n        if self.best_model is None:\n            raise ValueError(\"No model has been trained yet!\")\n        \n        predictions = self.predict(X_test)\n        report = classification_report(y_test, predictions, \n                                     target_names=['No Infection', 'Infection'])\n        return report\n\nif __name__ == \"__main__\":\n    # Test the ML pipeline\n    from data_generator import generate_synthetic_data\n    \n    print(\"Testing ML Pipeline...\")\n    \n    # Generate test data\n    data = generate_synthetic_data(1000)\n    \n    # Initialize and train pipeline\n    pipeline = MLPipeline()\n    results = pipeline.train_models(data)\n    \n    print(\"\\nModel Results:\")\n    for model_name, metrics in results.items():\n        print(f\"{model_name}: ROC AUC = {metrics['roc_auc']:.3f}\")\n    \n    # Test prediction\n    test_patient = data.iloc[[0]].drop('H_Pylori_Infection', axis=1)\n    prediction = pipeline.predict_proba(test_patient)\n    print(f\"\\nTest prediction probability: {prediction[0][1]:.3f}\")\n","size_bytes":15501},"ai_recommendations.py":{"content":"import os\nimport json\nfrom typing import Dict, Any, Optional\nimport google.genai as genai\nfrom google.genai import types\nfrom openai import OpenAI\n\n# Initialize AI clients\nOPENAI_API_KEY = os.environ.get(\"OPENAI_API_KEY\")\nGEMINI_API_KEY = os.environ.get(\"GEMINI_API_KEY\")\n\nopenai_client = None\ngemini_client = None\n\nif OPENAI_API_KEY:\n    openai_client = OpenAI(api_key=OPENAI_API_KEY)\n\nif GEMINI_API_KEY:\n    gemini_client = genai.Client(api_key=GEMINI_API_KEY)\n\nclass AIRecommendationEngine:\n    \"\"\"\n    AI-powered treatment recommendation system for H. Pylori infection\n    \"\"\"\n    \n    def __init__(self):\n        self.medical_guidelines = {\n            'high_risk': {\n                'urgency': 'Immediate medical attention required',\n                'testing': ['Stool antigen test', 'Urea breath test', 'Upper endoscopy'],\n                'treatment_approach': 'Triple or quadruple therapy',\n                'followup': '4-6 weeks post-treatment testing'\n            },\n            'medium_risk': {\n                'urgency': 'Medical evaluation recommended',\n                'testing': ['Stool antigen test', 'Urea breath test'],\n                'treatment_approach': 'Consider empirical treatment if positive',\n                'followup': 'Monitor symptoms and retest if needed'\n            },\n            'low_risk': {\n                'urgency': 'Routine screening adequate',\n                'testing': ['Consider testing only if symptomatic'],\n                'treatment_approach': 'Watchful waiting',\n                'followup': 'Annual screening if risk factors present'\n            }\n        }\n    \n    def create_patient_profile(self, patient_data: Dict[str, Any], \n                             risk_probability: float, risk_level: str) -> str:\n        \"\"\"\n        Create a comprehensive patient profile for AI analysis\n        \"\"\"\n        # Convert numeric codes to readable text\n        sex_text = \"Male\" if patient_data.get('Sex', 0) == 1 else \"Female\"\n        \n        residence_map = {0: \"Urban\", 1: \"County\", 2: \"Suburban\", 3: \"Village\"}\n        residence_text = residence_map.get(patient_data.get('Residence', 0), \"Unknown\")\n        \n        education_map = {0: \"Primary\", 1: \"Secondary\", 2: \"College\", 3: \"Bachelor\", 4: \"Postgraduate\"}\n        education_text = education_map.get(patient_data.get('Education', 0), \"Unknown\")\n        \n        smoking_map = {0: \"None\", 1: \"1-5/day\", 2: \"6-10/day\", 3: \">10/day\"}\n        smoking_text = smoking_map.get(patient_data.get('Smoking', 0), \"None\")\n        \n        alcohol_map = {0: \"None\", 1: \"Monthly\", 2: \"Weekly\", 3: \"3+/Weekly\"}\n        alcohol_text = alcohol_map.get(patient_data.get('Alcohol', 0), \"None\")\n        \n        profile = f\"\"\"\n        PATIENT CLINICAL PROFILE:\n        \n        Demographics:\n        - Age: {patient_data.get('Age', 'Unknown')} years\n        - Sex: {sex_text}\n        - Residence: {residence_text}\n        - Education: {education_text}\n        - Marital Status: {\"Married\" if patient_data.get('Marital_Status', 0) == 1 else \"Unmarried\"}\n        \n        Clinical History:\n        - BMI: {patient_data.get('BMI', 'Unknown')} kg/m²\n        - Previous Gastritis: {\"Yes\" if patient_data.get('Gastritis_History', 0) == 1 else \"No\"}\n        - Previous Ulcer Disease: {\"Yes\" if patient_data.get('Ulcer_History', 0) == 1 else \"No\"}\n        \n        Laboratory Values:\n        - Albumin: {patient_data.get('Albumin', 'Unknown')} g/L\n        - WBC Count: {patient_data.get('WBC_Count', 'Unknown')} ×10⁹/L\n        - Lymphocyte Count: {patient_data.get('Lymphocyte_Count', 'Unknown')} ×10⁹/L\n        - Neutrophil Count: {patient_data.get('Neutrophil_Count', 'Unknown')} ×10⁹/L\n        - RBC Count: {patient_data.get('RBC_Count', 'Unknown')} ×10¹²/L\n        - Hemoglobin: {patient_data.get('Hemoglobin', 'Unknown')} g/L\n        \n        Lifestyle Factors:\n        - Smoking: {smoking_text}\n        - Alcohol Consumption: {alcohol_text}\n        - Handwashing Frequency: {[\"Rarely\", \"Now & then\", \"Frequent\", \"Daily\"][patient_data.get('Handwashing', 3)]}\n        - Pickled Food Consumption: {[\"Rare\", \"Now & then\", \"Frequent\", \"Daily\"][patient_data.get('Pickled_Food', 0)]}\n        - Tableware Sharing: {[\"Rare\", \"Now & then\", \"Frequent\", \"Daily\"][patient_data.get('Tableware_Sharing', 0)]}\n        \n        Family History:\n        - Family H. Pylori History: {\"Yes\" if patient_data.get('Family_Pylori_History', 0) == 1 else \"No\"}\n        - Family Gastritis History: {\"Yes\" if patient_data.get('Family_Gastritis_History', 0) == 1 else \"No\"}\n        \n        RISK ASSESSMENT:\n        - H. Pylori Infection Probability: {risk_probability:.1%}\n        - Risk Level: {risk_level.upper()}\n        \n        ENDOSCOPIC FINDINGS (if available):\n        - Gastric Nodularity: {\"Yes\" if patient_data.get('Nodularity', 0) == 1 else \"No\" if patient_data.get('Nodularity', 0) == 0 else \"Not Available\"}\n        - Gastric Mucosal Redness: {\"Yes\" if patient_data.get('Gastric_Redness', 0) == 1 else \"No\" if patient_data.get('Gastric_Redness', 0) == 0 else \"Not Available\"}\n        \"\"\"\n        \n        return profile\n    \n    def get_openai_recommendation(self, patient_profile: str, risk_level: str) -> str:\n        \"\"\"\n        Get treatment recommendation using OpenAI GPT\n        \"\"\"\n        if not openai_client:\n            raise ValueError(\"OpenAI API key not configured\")\n        \n        system_prompt = \"\"\"\n        You are an experienced gastroenterologist and infectious disease specialist. \n        Provide evidence-based, personalized treatment recommendations for H. pylori infection \n        based on current medical guidelines (ACG, AGA, Maastricht VI consensus).\n        \n        Structure your response with:\n        1. Risk Assessment Summary\n        2. Recommended Diagnostic Tests\n        3. Treatment Plan (if indicated)\n        4. Lifestyle Modifications\n        5. Follow-up Care\n        6. Patient Education Points\n        \n        Be specific, actionable, and consider patient-specific factors.\n        Include contraindications and alternative approaches when relevant.\n        \"\"\"\n        \n        user_prompt = f\"\"\"\n        Based on the following patient profile, provide comprehensive treatment recommendations:\n        \n        {patient_profile}\n        \n        Consider the risk level ({risk_level}) and provide evidence-based recommendations \n        following current gastroenterology guidelines.\n        \"\"\"\n        \n        # the newest OpenAI model is \"gpt-5\" which was released August 7, 2025.\n        # do not change this unless explicitly requested by the user\n        response = openai_client.chat.completions.create(\n            model=\"gpt-5\",\n            messages=[\n                {\"role\": \"system\", \"content\": system_prompt},\n                {\"role\": \"user\", \"content\": user_prompt}\n            ],\n            max_completion_tokens=2048\n        )\n        \n        return response.choices[0].message.content\n    \n    def get_gemini_recommendation(self, patient_profile: str, risk_level: str) -> str:\n        \"\"\"\n        Get treatment recommendation using Google Gemini\n        \"\"\"\n        if not gemini_client:\n            raise ValueError(\"Gemini API key not configured\")\n        \n        prompt = f\"\"\"\n        You are an experienced gastroenterologist providing evidence-based treatment recommendations.\n        \n        Based on the following patient profile, provide comprehensive H. pylori management recommendations:\n        \n        {patient_profile}\n        \n        Please structure your response with:\n        1. **Risk Assessment Summary**\n        2. **Recommended Diagnostic Tests**\n        3. **Treatment Plan** (if indicated)\n        4. **Lifestyle Modifications**\n        5. **Follow-up Care**\n        6. **Patient Education Points**\n        \n        Follow current medical guidelines (ACG, AGA, Maastricht VI) and consider:\n        - Patient-specific risk factors\n        - Contraindications and drug interactions\n        - Local resistance patterns (assume standard patterns)\n        - Cost-effectiveness\n        \n        Risk Level: {risk_level}\n        \"\"\"\n        \n        response = gemini_client.models.generate_content(\n            model=\"gemini-2.5-pro\",\n            contents=prompt\n        )\n        \n        return response.text\n    \n    def add_clinical_guidelines(self, risk_level: str) -> str:\n        \"\"\"\n        Add evidence-based clinical guidelines to the recommendation\n        \"\"\"\n        guidelines = self.medical_guidelines.get(risk_level.lower(), {})\n        \n        guideline_text = f\"\"\"\n        \n        ## CLINICAL GUIDELINES ({risk_level.upper()} RISK)\n        \n        **Urgency**: {guidelines.get('urgency', 'Standard care')}\n        \n        **Recommended Testing**: {', '.join(guidelines.get('testing', ['Standard H. pylori testing']))}\n        \n        **Treatment Approach**: {guidelines.get('treatment_approach', 'Standard guidelines')}\n        \n        **Follow-up**: {guidelines.get('followup', 'As clinically indicated')}\n        \n        ## EVIDENCE-BASED TREATMENT OPTIONS\n        \n        **First-Line Therapy (Triple Therapy)**:\n        - PPI + Amoxicillin + Clarithromycin (14 days) - if clarithromycin resistance <15%\n        - PPI + Amoxicillin + Metronidazole (14 days) - alternative\n        \n        **Quadruple Therapy (Higher Efficacy)**:\n        - PPI + Bismuth + Metronidazole + Tetracycline (14 days)\n        - Concomitant: PPI + Amoxicillin + Clarithromycin + Metronidazole (14 days)\n        \n        **Second-Line Options**:\n        - Levofloxacin-based triple therapy\n        - Rifabutin-based therapy (refractory cases)\n        \n        ## IMPORTANT CONSIDERATIONS\n        - Always test for cure 4-8 weeks post-treatment\n        - Consider local antibiotic resistance patterns\n        - Screen for drug allergies and contraindications\n        - Patient compliance is crucial for success\n        \"\"\"\n        \n        return guideline_text\n\ndef get_ai_treatment_recommendation(patient_data: Dict[str, Any], \n                                  risk_probability: float, \n                                  risk_level: str,\n                                  preferred_ai: str = \"auto\") -> str:\n    \"\"\"\n    Get comprehensive AI-powered treatment recommendation\n    \n    Args:\n        patient_data: Dictionary containing patient information\n        risk_probability: Predicted probability of H. pylori infection\n        risk_level: Risk category (Low/Medium/High)\n        preferred_ai: \"openai\", \"gemini\", or \"auto\"\n    \n    Returns:\n        str: Comprehensive treatment recommendation\n    \"\"\"\n    \n    engine = AIRecommendationEngine()\n    \n    # Create patient profile\n    patient_profile = engine.create_patient_profile(\n        patient_data, risk_probability, risk_level\n    )\n    \n    # Get AI recommendation\n    try:\n        if preferred_ai == \"openai\" or (preferred_ai == \"auto\" and openai_client):\n            ai_recommendation = engine.get_openai_recommendation(patient_profile, risk_level)\n            ai_source = \"OpenAI GPT-5\"\n        elif preferred_ai == \"gemini\" or (preferred_ai == \"auto\" and gemini_client):\n            ai_recommendation = engine.get_gemini_recommendation(patient_profile, risk_level)\n            ai_source = \"Google Gemini\"\n        else:\n            raise ValueError(\"No AI service available\")\n        \n        # Add clinical guidelines\n        clinical_guidelines = engine.add_clinical_guidelines(risk_level)\n        \n        # Combine recommendations\n        full_recommendation = f\"\"\"\n# 🤖 AI-Powered Treatment Recommendation\n*Generated using {ai_source} with evidence-based medical guidelines*\n\n---\n\n{ai_recommendation}\n\n{clinical_guidelines}\n\n---\n\n## ⚠️ IMPORTANT DISCLAIMER\nThis recommendation is generated by AI based on clinical data and current medical guidelines. \nIt is intended for educational purposes and to assist healthcare providers in clinical decision-making. \n**Always consult with a qualified healthcare professional for proper diagnosis and treatment.**\n\n**This recommendation should not replace professional medical advice, diagnosis, or treatment.**\n        \"\"\"\n        \n        return full_recommendation\n        \n    except Exception as e:\n        # Fallback recommendation based on risk level\n        fallback = engine.create_fallback_recommendation(patient_data, risk_probability, risk_level)\n        return f\"\"\"\n# 🏥 Clinical Guideline-Based Recommendation\n*AI service temporarily unavailable - showing evidence-based clinical guidelines*\n\n{fallback}\n\n---\n\n## ⚠️ IMPORTANT DISCLAIMER\nThis recommendation is based on standard clinical guidelines for H. pylori management.\n**Always consult with a qualified healthcare professional for proper diagnosis and treatment.**\n        \"\"\"\n\ndef create_fallback_recommendation(patient_data: Dict[str, Any], \n                                 risk_probability: float, \n                                 risk_level: str) -> str:\n    \"\"\"\n    Create a fallback recommendation when AI services are unavailable\n    \"\"\"\n    \n    engine = AIRecommendationEngine()\n    \n    risk_guidelines = engine.medical_guidelines.get(risk_level.lower(), {})\n    \n    recommendation = f\"\"\"\n## Risk Assessment\n- **H. Pylori Infection Probability**: {risk_probability:.1%}\n- **Risk Level**: {risk_level.upper()}\n- **Clinical Priority**: {risk_guidelines.get('urgency', 'Standard care')}\n\n## Recommended Actions\n\n### Diagnostic Testing\n{chr(10).join(['- ' + test for test in risk_guidelines.get('testing', ['Standard H. pylori testing'])])}\n\n### Treatment Approach\n- **Strategy**: {risk_guidelines.get('treatment_approach', 'Follow standard guidelines')}\n- **Follow-up**: {risk_guidelines.get('followup', 'As clinically indicated')}\n\n### Key Risk Factors Identified\n    \"\"\"\n    \n    # Add risk factor analysis\n    risk_factors = []\n    \n    if patient_data.get('Gastritis_History', 0) == 1:\n        risk_factors.append(\"Previous gastritis history\")\n    \n    if patient_data.get('Ulcer_History', 0) == 1:\n        risk_factors.append(\"Previous ulcer disease\")\n    \n    if patient_data.get('Family_Pylori_History', 0) == 1:\n        risk_factors.append(\"Family history of H. pylori\")\n    \n    if patient_data.get('Smoking', 0) > 0:\n        risk_factors.append(\"Smoking history\")\n    \n    if patient_data.get('Pickled_Food', 0) > 2:\n        risk_factors.append(\"High pickled food consumption\")\n    \n    if risk_factors:\n        recommendation += \"\\n\" + \"\\n\".join(['- ' + factor for factor in risk_factors])\n    else:\n        recommendation += \"\\n- No major risk factors identified\"\n    \n    recommendation += f\"\"\"\n\n### Lifestyle Recommendations\n- Improve hand hygiene practices\n- Reduce consumption of pickled and processed foods\n- Consider smoking cessation if applicable\n- Maintain good nutritional status\n- Follow proper food safety practices\n\n### Follow-up Care\n- {risk_guidelines.get('followup', 'Schedule appropriate follow-up based on clinical judgment')}\n- Monitor symptoms and report any worsening\n- Ensure treatment compliance if therapy is initiated\n    \"\"\"\n    \n    return recommendation\n\n# Attach method to class\nAIRecommendationEngine.create_fallback_recommendation = create_fallback_recommendation\n\nif __name__ == \"__main__\":\n    # Test the recommendation system\n    test_patient = {\n        'Age': 45,\n        'Sex': 1,\n        'BMI': 26.5,\n        'Gastritis_History': 1,\n        'Ulcer_History': 0,\n        'Family_Pylori_History': 1,\n        'Smoking': 1,\n        'Alcohol': 2,\n        'Handwashing': 2,\n        'Pickled_Food': 2\n    }\n    \n    try:\n        recommendation = get_ai_treatment_recommendation(\n            test_patient, 0.75, \"High\"\n        )\n        print(\"AI Recommendation Generated Successfully!\")\n        print(recommendation[:500] + \"...\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n","size_bytes":15803},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"google-genai>=1.43.0\",\n    \"imbalanced-learn\",\n    \"joblib\",\n    \"matplotlib\",\n    \"openai>=2.3.0\",\n    \"plotly\",\n    \"scikit-learn\",\n    \"scipy\",\n    \"seaborn\",\n    \"streamlit>=1.50.0\",\n    \"xgboost\",\n]\n\n[[tool.uv.index]]\nexplicit = true\nname = \"pytorch-cpu\"\nurl = \"https://download.pytorch.org/whl/cpu\"\n\n[tool.uv.sources]\nAA-module = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nABlooper = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nAnalysisG = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nAutoRAG = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nBERTeam = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nBxTorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nByaldi = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nCALM-Pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nCOPEX-high-rate-compression-quality-metrics = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nCityLearn = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nCoCa-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nCoLT5-attention = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nComfyUI-EasyNodes = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nCrawl4AI = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nDALL-E = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nDI-toolkit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nDatasetRising = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nDeepCache = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nDeepMatter = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nDraugr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nESRNN = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nEn-transformer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nExpoSeq = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nFLAML = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nFSRS-Optimizer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nGANDLF = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nGQLAlchemy = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nGhostScan = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nGraKeL = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nHEBO = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nIOPaint = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nISLP = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nInvokeAI = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nJAEN = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nKapoorLabs-Lightning = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nLightAutoML = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nLingerGRN = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nMMEdu = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nMRzeroCore = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nModeva = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nNeuralFoil = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nNiMARE = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nNinjaTools = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nOpenHosta = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nOpenNMT-py = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nPOT = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nPVNet = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nPaLM-rlhf-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nPepperPepper = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nPiML = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nPoutyne = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nQNCP = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nRAGatouille = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nRareGO = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nRealtimeSTT = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nRelevanceAI-Workflows-Core = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nResemblyzer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nScandEval = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nSimba-UW-tf-dev = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nSwissArmyTransformer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nTPOT = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nTTS = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nTorchCRF = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nTotalSegmentator = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nUtilsRL = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nWhisperSpeech = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nXAISuite = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\na-unet = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\na5dev = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naccelerate = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naccelerated-scan = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naccern-xyme = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nachatbot = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nacids-rave = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nactorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nacvl-utils = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nadabelief-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nadam-atan2-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nadan-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nadapters = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nadmin-torch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nadtoolbox = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nadversarial-robustness-toolbox = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naeiou = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naeon = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nafricanwhisper = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nag-llama-api = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nagentdojo = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nagilerl = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nai-edge-torch-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nai-parrot = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nai-python = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nai-transform = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nai2-olmo = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nai2-olmo-core = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nai2-tango = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naicmder = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naider-chat = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naider-chat-x = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naif360 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naihwkit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naimodelshare = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nairllm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nairtestProject = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nairunner = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naisak = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naislib = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naisquared = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naistore = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naithree = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nakasha-terminal = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nalibi = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nalibi-detect = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nalignn = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nall-clip = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nallennlp = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nallennlp-models = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nallennlp-pvt-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nallophant = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nallosaurus = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naloy = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nalpaca-eval = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nalphafold2-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nalphafold3-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nalphamed-federated = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nalphawave = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\namazon-braket-pennylane-plugin = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\namazon-photos = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nanemoi-graphs = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nanemoi-models = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nanomalib = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\napache-beam = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\napache-tvm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naperturedb = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naphrodite-engine = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naqlm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\narcAGI2024 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\narchisound = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nargbind = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\narize = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\narm-pytorch-utilities = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\narray-api-compat = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\narus = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nassert-llm-tools = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nasteroid = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nasteroid-filterbanks = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nastra-llm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nastrovision = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\natomate2 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nattacut = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naudio-diffusion-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naudio-encoders-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naudio-separator = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naudiocraft = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naudiolm-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nauralis = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nauraloss = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nauto-gptq = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nautoawq = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nautoawq-kernels = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\n\"autogluon.multimodal\" = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\n\"autogluon.tabular\" = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\n\"autogluon.timeseries\" = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nautotrain-advanced = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\navdeepfake1m = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\naws-fortuna = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nax-platform = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nazureml-automl-dnn-vision = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nazureml-contrib-automl-dnn-forecasting = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nazureml-evaluate-mlflow = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nazureml-metrics = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nazureml-train-automl = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nb2bTools = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbackpack-for-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbalrog-nle = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbatch-face = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbatchalign = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbatchgeneratorsv2 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbatchtensor = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbbrl = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbenchpots = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbent = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbert-score = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbertopic = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbertviz = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbestOf = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbetty-ml = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbig-sleep = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbigdl-core-cpp = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbigdl-core-npu = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbigdl-llm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbigdl-nano = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\n\"bioimageio.core\" = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbitfount = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbitsandbytes = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbittensor = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbittensor-cli = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nblackboxopt = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nblanc = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nblindai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbm25-pt = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nboltz = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbotorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nboxmot = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbrainchain = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbraindecode = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbrevitas = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbriton = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbrowsergym-visualwebarena = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbuzz-captions = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbyotrack = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nbyzerllm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nc4v-py = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncalflops = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncame-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncamel-ai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncamel-tools = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncannai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncaptum = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncarte-ai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncarvekit-colab = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncatalyst = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncausalml = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncausalnex = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncausy = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncbrkit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncca-zoo = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncdp-backend = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncellacdc = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncellfinder = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncellpose = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncellxgene-census = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nchattts = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nchemprop = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nchgnet = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nchitra = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncircuitsvis = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncjm-yolox-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nclarinpl-embeddings = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nclass-resolver = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nclassifier-free-guidance-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nclassiq = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nclassy-core = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nclean-fid = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncleanvision = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nclip-anytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nclip-benchmark = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nclip-by-openai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nclip-interrogator = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nclip-retrieval = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncltk = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nclu = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nclusterops = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncnocr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncnstd = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncoba = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncofi = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncolbert-ai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncolpali-engine = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncompel = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncomposabl-ray = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncomposabl-ray-dev = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncomposabl-train = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncomposabl-train-dev = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncomposer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncompressai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncompressed-tensors = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncompressed-tensors-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nconcrete-python = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nconfit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nconformer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncontextualSpellCheck = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncontinual-inference = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncontrolnet-aux = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nconvokit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncoola = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncoqui-tts = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncoqui-tts-trainer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncraft-text-detector = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncreme = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncrocodile = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncrowd-kit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncryoSPHERE = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncsle-common = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncsle-system-identification = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nctgan = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncurated-transformers = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncut-cross-entropy = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncvat-sdk = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ncybertask = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nd3rlpy = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndalle-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndalle2-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndanila-lib = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndanling = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndarts = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndarwin-py = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndata-gradients = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndatachain = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndataclass-array = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndataeval = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndatarobot-drum = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndatarobotx = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndatasets = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndatumaro = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndctorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeep-utils = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeepchecks = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeepchem = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeepctr-torch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeepecho = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeepepochs = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeepforest = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeeplabcut = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeepmd-kit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeepmultilingualpunctuation = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeepparse = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeeprobust = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeepsparse = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeepsparse-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndeepspeed = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndenoising-diffusion-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndescript-audio-codec = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndescript-audiotools = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndetecto = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndetoxify = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndgenerate = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndghs-imgutils = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndgl = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndialogy = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndice-ml = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndiffgram = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndiffq = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndiffusers = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndistilabel = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndistrifuser = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndnikit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndocarray = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndoclayout-yolo = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndocling-ibm-models = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndocquery = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndomino-code-assist = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndreamsim = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndropblock = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndruida = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ndvclive = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ne2-tts-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ne2cnn = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ne3nn = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\neasyocr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nebtorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\necallisto-ng = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nedsnlp = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\neffdet = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\neinx = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\neir-dl = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\neis1600 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\neland = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nema-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nembedchain = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nenformer-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nentmax = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nesm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nespaloma-charge = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nespnet = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\netils = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\netna = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nevadb = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nevalscope = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nevaluate = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nexllamav2 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nextractable = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nface-alignment = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfacenet-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfacexlib = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfair-esm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfairseq = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfairseq2 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfairseq2n = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfaker-file = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfarm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfast-bert = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfast-pytorch-kmeans = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfastai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfastcore = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfastestimator-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfasttreeshap = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfedml = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfelupe = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfemr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfft-conv-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfickling = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfireworks-ai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nflair = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nflashrag-dev = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nflax = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nflexgen = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nflgo = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nflopth = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nflowcept = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nflytekitplugins-kfpytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nflytekitplugins-onnxpytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfmbench = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfocal-frequency-loss = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfoldedtensor = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfractal-tasks-core = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfreegenius = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfreqtrade = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfschat = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfunasr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfunctorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfunlbm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nfunsor = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngalore-torch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngarak = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngarf = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngateloop-transformer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngeffnet = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngenutility = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngfpgan = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngigagan-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngin-config = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nglasflow = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngliner = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngluonts = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngmft = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngoogle-cloud-aiplatform = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngpforecaster = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngpt3discord = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngpytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngrad-cam = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngraph-weather = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngraphistry = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngravitorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngretel-synthetics = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngsplat = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nguardrails-ai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nguidance = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ngymnasium = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhanlp = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhappytransformer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhbutils = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nheavyball = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhezar = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhf-deepali = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhf-doc-builder = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhigher = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhjxdl = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhkkang-utils = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhordelib = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhpsv2 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhuggingface-hub = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhummingbird-ml = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhvae-backbone = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhya = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nhypothesis-torch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nibm-metrics-plugin = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nibm-watson-machine-learning = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nibm-watsonx-ai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nicetk = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nicevision = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\niden = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nidvpackage = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\niglovikov-helper-functions = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nimagededup = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nimagen-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nimaginAIry = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nimg2vec-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nincendio = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ninference = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ninference-gpu = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ninfinity-emb = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ninfo-nce-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ninfoapps-mlops-sdk = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ninstructlab = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ninstructlab-dolomite = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ninstructlab-eval = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ninstructlab-sdg = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ninstructlab-training = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ninvisible-watermark = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\niobm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nipex-llm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\niree-turbine = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nirisml = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nirisml-tasks-azure-openai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nirisml-tasks-torchvision = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nirisml-tasks-training = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nitem-matching = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nivadomed = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\njaqpotpy = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\njina = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\njudo = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\njunky = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nk-diffusion = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nk1lib = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nk2 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkappadata = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkappamodules = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkarbonn = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkats = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkbnf = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkedro-datasets = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkeybert = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkeytotext = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkhoj = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkiui = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkonfuzio-sdk = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkornia = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkornia-moons = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkraken = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkwarray = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nkwimage = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlabml-nn = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlagent = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlaion-clap = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlale = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlama-cleaner = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlancedb = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlangcheck = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlangkit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlangroid = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlangtest = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlayoutparser = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nldp = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nleafmap = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nleap-ie = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nleibniz = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nleptonai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nletmedoit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlhotse = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlib310 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlibpecos = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlibrec-auto = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlibretranslate = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nliger-kernel = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nliger-kernel-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlightning = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlightning-bolts = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlightning-fabric = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlightning-habana = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlightning-lite = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlightrag = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlightweight-gan = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlightwood = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlinear-attention-transformer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlinear-operator = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlinformer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlinformer-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nliom-toolkit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlion-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlit-nlp = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlitdata = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlitelama = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlitgpt = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nllama-index-embeddings-adapter = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nllama-index-embeddings-clip = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nllama-index-embeddings-instructor = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nllama-index-llms-huggingface = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nllama-index-postprocessor-colbert-rerank = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nllm-blender = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nllm-foundry = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nllm-guard = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nllm-rs = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nllm2vec = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nllmcompressor = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nllmlingua = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nllmvm-cli = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlm-eval = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlmdeploy = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlmms-eval = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlocal-attention = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlovely-tensors = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlpips = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nlycoris-lora = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmace-torch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmagic-pdf = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmagicsoup = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmagvit2-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmaite = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmanga-ocr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmanifest-ml = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmanipulation = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmarker-pdf = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmatgl = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmed-imagetools = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmedaka = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmedcat = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmedmnist = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmegablocks = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmegatron-energon = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmemos = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmeshgpt-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmetatensor-torch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmflux = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmia-vgg = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmiditok = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nminari = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nminicons = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nml2rt = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmlagents = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmlbench-core = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmlcroissant = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmlpfile = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmlx = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmlx-whisper = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmmaction2 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmmengine = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmmengine-lite = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmmocr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmmpose = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmmsegmentation = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmodeci-mdf = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmodel2vec = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmodelscope = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmodelspec = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmonai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmonai-weekly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmonotonic-alignment-search = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmonty = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmosaicml = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmosaicml-streaming = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmoshi = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmteb = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmtmtrain = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmulti-quantization = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nmyhand = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnGPT-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnaeural-core = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnapari = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnapatrackmater = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnara-wpe = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnatten = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnbeats-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnebulae = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnemo-toolkit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nneptune = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nneptune-client = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnerfacc = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnerfstudio = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnessai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnetcal = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nneural-rag = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nneuralforecast = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nneuralnets = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nneuralprophet = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nneuspell = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnevergrad = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnexfort = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnimblephysics = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnirtorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnkululeko = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnlp = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnlptooltest = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnnAudio = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnnodely = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnnsight = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnnunetv2 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnoisereduce = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnonebot-plugin-nailongremove = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnowcasting-dataloader = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnowcasting-forecast = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnshtrainer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnuwa-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnvflare = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nnvidia-modelopt = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nocf-datapipes = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nocnn = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nogb = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nohmeow-blurr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nolive-ai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nomlt = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nommlx = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nonediff = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nonediffx = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nonnx2pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nonnx2torch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nopacus = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nopen-clip-torch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nopen-flamingo = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nopen-interpreter = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nopenbb-terminal-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nopenmim = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nopenparse = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nopenunmix = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nopenvino-dev = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nopenvino-tokenizers = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nopenvino-xai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nopenwakeword = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nopt-einsum-fx = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\noptimum = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\noptimum-habana = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\noptimum-intel = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\noptimum-neuron = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\noptimum-quanto = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\noptree = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\noptuna = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\noptuna-dashboard = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\noptuna-integration = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\noracle-ads = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\norbit-ml = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\notx = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\noutetts = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\noutlines = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\noutlines-core = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npaddlenlp = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npai-easycv = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npandasai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npanns-inference = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npatchwork-cli = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npeft = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npegasuspy = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npelutils = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npenn = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nperforatedai-freemium = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nperformer-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npetastorm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npfio = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npgmpy = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nphenolrs = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nphobos = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npi-zero-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npinecone-text = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npiq = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npix2tex = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npix2text = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npnnx = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npolicyengine-us-data = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npolyfuzz = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npomegranate = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npositional-encodings = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nprefigure = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nproduct-key-memory = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nptflops = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nptwt = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npulser-core = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npunctuators = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npy2ls = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npyabsa = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\n\"pyannote.audio\" = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npyawd = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npyclarity = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npycox = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npyfemtet = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npyg-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npygrinder = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npyhealth = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npyhf = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npyiqa = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npykeen = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npykeops = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npylance = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npylineaGT = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npymanopt = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npymde = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npypots = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npyqlib = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npyqtorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npyro-ppl = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npysentimiento = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npyserini = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npysr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npythainlp = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npython-doctr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-fid = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-forecasting = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-ignite = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-kinematics = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-lightning = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-lightning-bolts = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-metric-learning = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-model-summary = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-msssim = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-pfn-extras = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-pretrained-bert = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-ranger = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-seed = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-tabnet = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-tabular = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-toolbelt = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-transformers = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-transformers-pvt-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-triton-rocm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-warmup = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch-wavelets = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch_optimizer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorch_revgrad = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorchcv = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npytorchltr2 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npyvene = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\npyvespa = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nqianfan = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nqibo = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nqiskit-machine-learning = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nqtorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nquanto = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nquick-anomaly-detector = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrastervision = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrastervision-pytorch-backend = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrastervision-pytorch-learner = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nray-lightning = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrclip = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrealesrgan = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrecbole = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrecommenders = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nredcat = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nreformer-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nregex-sampler = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nreplay-rec = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrerankers = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nresearch-framework = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nresemble-enhance = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nresnest = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrf-clip = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrf-groundingdino = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrfconv = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrich-logger = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nring-attention-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrltrade-test = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrotary-embedding-torch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrsp-ml = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nrust-circuit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ns2fft = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ns3prl = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ns3torchconnector = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsaferx = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsafetensors = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsagemaker-huggingface-inference-toolkit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsagemaker-ssh-helper = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsalesforce-lavis = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsalesforce-merlion = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsamv2 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nscib = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nscib-metrics = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nscvi-tools = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsdmetrics = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsecretflow = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsegment-anything-hq = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsegment-anything-py = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsegmentation-models-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nself-rewarding-lm-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsemantic-kernel = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsemantic-router = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsenselab = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsent2vec = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsentence-transformers = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsequence-model-train = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nserotiny = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsevenn = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsglang = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nshap = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsilero-api-server = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsilero-vad = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsilicondiff-npu = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsimclr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsimple-lama-inpainting = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsinabs = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsixdrepnet = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nskforecast = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nskorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nskrl = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nskt = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsktime = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsktmls = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nslangtorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsmartnoise-synth = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsmashed = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsmplx = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsmqtk-descriptors = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsmqtk-detection = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsnntorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsnorkel = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsnowflake-ml-python = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nso-vits-svc-fork = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsonusai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsony-custom-layers = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsotopia = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspacr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspacy-curated-transformers = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspacy-experimental = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspacy-huggingface-pipelines = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspacy-llm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspacy-transformers = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspan-marker = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspandrel = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspandrel-extra-arches = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsparrow-python = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspatialdata = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspeechbrain = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspeechtokenizer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspikeinterface = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspikingjelly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspotiflow = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspotpython = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nspotriver = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsquirrel-core = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nstable-baselines3 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nstable-diffusion-sdkit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nstable-ts = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nstanford-stk = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nstanfordnlp = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nstanza = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nstartorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nstreamtasks = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nstruct-eqtable = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nstylegan2-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsupar = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsuper-gradients = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsuper-image = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsuperlinked = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsupervisely = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsurya-ocr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsvdiff-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nswarm-models = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nswarmauri = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nswarms-memory = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nswebench = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsyft = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsympytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsyne-tune = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nsynthcity = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nt5 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntab-transformer-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntabpfn = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntaming-transformers = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntaming-transformers-rom1504 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntaskwiz = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntbparse = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntecton = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntensor-parallel = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntensorcircuit-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntensordict = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntensordict-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntensorizer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntensorrt-llm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntexify = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntext2text = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntextattack = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntfkit = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nthepipe-api = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nthinc = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nthingsvision = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nthirdai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nthop = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntianshou = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntidy3d = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntimesfm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntimm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntipo-kgen = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntmnt = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntoad = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntomesd = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntop2vec = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-audiomentations = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-dct = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-delaunay = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-directml = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-ema = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-encoding = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-fidelity = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-geometric = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-geopooling = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-harmonics = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-kmeans = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-lr-finder = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-max-mem = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-npu = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-optimi = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-optimizer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-ort = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-pitch-shift = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-ppr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-pruning = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-snippets = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-stoi = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-struct = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorch-tensorrt = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchani = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchattacks = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchaudio = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchbiggraph = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchcam = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchcde = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchcfm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchcrepe = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchdata = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchdatasets-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchdiffeq = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchdyn = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchestra = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorcheval = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorcheval-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchextractor = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchfcpe = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchfun = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchfunc-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchgeo = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchgeometry = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchio = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchjpeg = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchlayers-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchmeta = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchmetrics = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchmocks = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchpack = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchpippy = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchpq = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchprofile = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchquantlib = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchrec = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchrec-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchrec-nightly-cpu = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchrl = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchrl-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchscale = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchsde = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchseg = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchserve = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchserve-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchsnapshot-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchsr = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchstain = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchsummaryX = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchtext = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchtnt = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchtnt-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchtyping = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchutil = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchvinecopulib = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchvision = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchviz = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchx = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchx-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntorchxrayvision = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntotalspineseg = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntracebloc-package-dev = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntrainer = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntransformer-engine = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntransformer-lens = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntransformer-smaller-training-vocab = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntransformers = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntransformers-domain-adaptation = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntransfusion-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntransparent-background = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntreescope = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntrolo = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntsai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntslearn = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nttspod = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntxtai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\ntyro = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nu8darts = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nuhg = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nuitestrunner-syberos = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nultimate-rvc = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nultralytics = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nultralytics-thop = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nunav = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nunbabel-comet = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nunderthesea = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nunfoldNd = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nunimernet = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nunitorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nunitxt = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nunsloth = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nunsloth-zoo = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nunstructured = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nunstructured-inference = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nutilsd = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nv-diffusion-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvIQA = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvectice = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvector-quantize-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvectorhub-nightly = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nversatile-audio-upscaler = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvertexai = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvesin = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvgg-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvideo-representations-extractor = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nviser = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvision-datasets = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvisionmetrics = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvisu3d = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvit-pytorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nviturka-nn = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvllm = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvllm-flash-attn = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvocos = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvollseg = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nvtorch = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nwavmark = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nwdoc = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nwhisper-live = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nwhisper-timestamped = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nwhisperx = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nwilds = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nwordllama = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nworker-automate-hub = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nwxbtool = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nx-clip = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nx-transformers = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nxaitk_saliency = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nxformers = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nxgrammar = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nxinference = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nxtts-api-server = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nyolo-poser = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nyolov5 = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nyolov7-package = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nyta-general-utils = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nzensvi = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nzetascale = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\nzuko = [{ index = \"pytorch-cpu\", marker = \"platform_system == 'Linux'\" }]\n","size_bytes":90731},"setup_model.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nH. Pylori Prediction Model - One-Time Setup Script\n\nThis script performs the one-time setup for the H. Pylori infection prediction system:\n1. Generates synthetic training data\n2. Trains and validates multiple ML models\n3. Saves the best performing model\n\nRun this script only once during initial setup or when you need to retrain the model.\n\"\"\"\n\nfrom data_generator import generate_synthetic_data\nfrom ml_pipeline import MLPipeline\nimport os\nimport pandas as pd\n\ndef main():\n    print('='*70)\n    print('H. PYLORI PREDICTION MODEL - ONE-TIME SETUP')\n    print('='*70)\n    \n    # Step 1: Generate synthetic training data\n    print('\\n📊 Step 1: Generating synthetic patient data...')\n    print('-' * 70)\n    \n    n_samples = 1000\n    data = generate_synthetic_data(n_samples)\n    \n    print(f'✓ Generated {len(data)} patient records')\n    print(f'✓ Features: {data.shape[1]} columns')\n    print(f'✓ H. Pylori infection prevalence: {data[\"H_Pylori_Infection\"].mean():.1%}')\n    \n    # Save the training dataset\n    os.makedirs('data', exist_ok=True)\n    data.to_csv('data/training_data.csv', index=False)\n    print(f'✓ Training data saved to: data/training_data.csv')\n    \n    # Step 2: Train machine learning models\n    print('\\n🤖 Step 2: Training machine learning models...')\n    print('-' * 70)\n    \n    pipeline = MLPipeline()\n    results = pipeline.train_models(data)\n    \n    # Step 3: Display results\n    print('\\n📈 Step 3: Model Performance Summary')\n    print('-' * 70)\n    print(f'{\"Model\":<25} {\"Accuracy\":<12} {\"Precision\":<12} {\"Recall\":<12} {\"ROC-AUC\":<12}')\n    print('-' * 70)\n    \n    for model_name, metrics in results.items():\n        print(f'{model_name:<25} {metrics[\"accuracy\"]:<12.3f} {metrics[\"precision\"]:<12.3f} '\n              f'{metrics[\"recall\"]:<12.3f} {metrics[\"roc_auc\"]:<12.3f}')\n    \n    # Step 4: Save the best model\n    print('\\n💾 Step 4: Saving the best model...')\n    print('-' * 70)\n    \n    best_model_name = pipeline.best_model_name\n    best_roc_auc = results[best_model_name]['roc_auc']\n    \n    os.makedirs('models', exist_ok=True)\n    pipeline.save_model('models/best_model.joblib', 'models/preprocessor.joblib')\n    \n    print(f'✓ Best Model: {best_model_name}')\n    print(f'✓ ROC-AUC Score: {best_roc_auc:.3f}')\n    print(f'✓ Model saved to: models/best_model.joblib')\n    print(f'✓ Preprocessor saved to: models/preprocessor.joblib')\n    \n    # Step 5: Test prediction\n    print('\\n🧪 Step 5: Testing prediction...')\n    print('-' * 70)\n    \n    test_patient = data.iloc[[0]].drop('H_Pylori_Infection', axis=1)\n    prediction_proba = pipeline.predict_proba(test_patient)\n    prediction = pipeline.predict(test_patient)\n    \n    print(f'✓ Test Patient Prediction:')\n    print(f'  - No Infection Probability: {prediction_proba[0][0]:.1%}')\n    print(f'  - Infection Probability: {prediction_proba[0][1]:.1%}')\n    print(f'  - Predicted Class: {\"Infected\" if prediction[0] == 1 else \"Not Infected\"}')\n    \n    # Summary\n    print('\\n' + '='*70)\n    print('✅ SETUP COMPLETED SUCCESSFULLY!')\n    print('='*70)\n    print('\\nThe H. Pylori prediction system is now ready for use.')\n    print('\\nNext Steps:')\n    print('1. Start the Streamlit app: streamlit run app.py --server.port 5000')\n    print('2. Navigate to the \"AI Settings\" page to configure your API keys')\n    print('3. Use the \"Patient Prediction\" page to predict infection risk')\n    print('\\nFor more information, see README.md')\n    print('='*70)\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":3549},"model_utils.py":{"content":"import numpy as np\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nfrom sklearn.metrics import confusion_matrix, roc_curve, auc, precision_recall_curve\nfrom sklearn.model_selection import learning_curve\nimport warnings\nwarnings.filterwarnings('ignore')\n\nclass ModelUtils:\n    \"\"\"\n    Utility class for model visualization and interpretation\n    \"\"\"\n    \n    def __init__(self):\n        self.colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd']\n        \n    def plot_confusion_matrix(self, y_true, y_pred, labels=None, title=\"Confusion Matrix\"):\n        \"\"\"\n        Plot confusion matrix using plotly\n        \"\"\"\n        cm = confusion_matrix(y_true, y_pred)\n        \n        if labels is None:\n            labels = ['No Infection', 'Infection']\n            \n        # Calculate percentages\n        cm_percent = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis] * 100\n        \n        # Create text annotations\n        text = []\n        for i in range(len(labels)):\n            text_row = []\n            for j in range(len(labels)):\n                text_row.append(f'{cm[i,j]}<br>({cm_percent[i,j]:.1f}%)')\n            text.append(text_row)\n        \n        fig = go.Figure(data=go.Heatmap(\n            z=cm,\n            x=labels,\n            y=labels,\n            text=text,\n            texttemplate=\"%{text}\",\n            textfont={\"size\": 12},\n            colorscale='Blues'\n        ))\n        \n        fig.update_layout(\n            title=title,\n            xaxis_title='Predicted Label',\n            yaxis_title='True Label',\n            width=500,\n            height=400\n        )\n        \n        return fig\n    \n    def plot_roc_curves(self, models_data, title=\"ROC Curves Comparison\"):\n        \"\"\"\n        Plot ROC curves for multiple models\n        \n        Args:\n            models_data: Dict with model names as keys and (fpr, tpr, auc_score) as values\n        \"\"\"\n        fig = go.Figure()\n        \n        for i, (model_name, (fpr, tpr, auc_score)) in enumerate(models_data.items()):\n            fig.add_trace(go.Scatter(\n                x=fpr,\n                y=tpr,\n                mode='lines',\n                name=f'{model_name} (AUC = {auc_score:.3f})',\n                line=dict(color=self.colors[i % len(self.colors)], width=2)\n            ))\n        \n        # Add diagonal line\n        fig.add_trace(go.Scatter(\n            x=[0, 1],\n            y=[0, 1],\n            mode='lines',\n            name='Random Classifier',\n            line=dict(dash='dash', color='gray', width=1)\n        ))\n        \n        fig.update_layout(\n            title=title,\n            xaxis_title='False Positive Rate',\n            yaxis_title='True Positive Rate',\n            xaxis=dict(range=[0, 1]),\n            yaxis=dict(range=[0, 1]),\n            width=700,\n            height=500,\n            legend=dict(x=0.6, y=0.1)\n        )\n        \n        return fig\n    \n    def plot_precision_recall_curve(self, y_true, y_scores, title=\"Precision-Recall Curve\"):\n        \"\"\"\n        Plot precision-recall curve\n        \"\"\"\n        precision, recall, _ = precision_recall_curve(y_true, y_scores)\n        avg_precision = auc(recall, precision)\n        \n        fig = go.Figure()\n        \n        fig.add_trace(go.Scatter(\n            x=recall,\n            y=precision,\n            mode='lines',\n            name=f'Precision-Recall (AP = {avg_precision:.3f})',\n            line=dict(color=self.colors[0], width=2)\n        ))\n        \n        # Add baseline\n        baseline = y_true.mean()\n        fig.add_hline(y=baseline, line_dash=\"dash\", line_color=\"gray\",\n                     annotation_text=f\"Baseline (AP = {baseline:.3f})\")\n        \n        fig.update_layout(\n            title=title,\n            xaxis_title='Recall',\n            yaxis_title='Precision',\n            xaxis=dict(range=[0, 1]),\n            yaxis=dict(range=[0, 1]),\n            width=600,\n            height=400\n        )\n        \n        return fig\n    \n    def plot_feature_importance(self, feature_names, importances, top_n=20, \n                               title=\"Feature Importance\"):\n        \"\"\"\n        Plot feature importance\n        \"\"\"\n        # Create DataFrame and sort\n        importance_df = pd.DataFrame({\n            'feature': feature_names,\n            'importance': importances\n        }).sort_values('importance', ascending=True).tail(top_n)\n        \n        fig = px.bar(\n            importance_df,\n            x='importance',\n            y='feature',\n            orientation='h',\n            title=title,\n            color='importance',\n            color_continuous_scale='viridis'\n        )\n        \n        fig.update_layout(\n            width=800,\n            height=max(400, top_n * 25),\n            yaxis_title='Features',\n            xaxis_title='Importance Score'\n        )\n        \n        return fig\n    \n    def plot_learning_curves(self, estimator, X, y, cv=5, title=\"Learning Curves\"):\n        \"\"\"\n        Plot learning curves to assess model performance vs training size\n        \"\"\"\n        train_sizes, train_scores, val_scores = learning_curve(\n            estimator, X, y, cv=cv, n_jobs=-1, \n            train_sizes=np.linspace(0.1, 1.0, 10),\n            scoring='roc_auc'\n        )\n        \n        train_mean = np.mean(train_scores, axis=1)\n        train_std = np.std(train_scores, axis=1)\n        val_mean = np.mean(val_scores, axis=1)\n        val_std = np.std(val_scores, axis=1)\n        \n        fig = go.Figure()\n        \n        # Training scores\n        fig.add_trace(go.Scatter(\n            x=train_sizes,\n            y=train_mean,\n            mode='lines+markers',\n            name='Training Score',\n            line=dict(color=self.colors[0]),\n            error_y=dict(\n                type='data',\n                array=train_std,\n                visible=True\n            )\n        ))\n        \n        # Validation scores\n        fig.add_trace(go.Scatter(\n            x=train_sizes,\n            y=val_mean,\n            mode='lines+markers',\n            name='Validation Score',\n            line=dict(color=self.colors[1]),\n            error_y=dict(\n                type='data',\n                array=val_std,\n                visible=True\n            )\n        ))\n        \n        fig.update_layout(\n            title=title,\n            xaxis_title='Training Set Size',\n            yaxis_title='ROC AUC Score',\n            width=700,\n            height=400\n        )\n        \n        return fig\n    \n    def plot_prediction_distribution(self, y_true, y_pred_proba, title=\"Prediction Distribution\"):\n        \"\"\"\n        Plot distribution of prediction probabilities by true class\n        \"\"\"\n        df = pd.DataFrame({\n            'probability': y_pred_proba,\n            'true_class': ['Infection' if x == 1 else 'No Infection' for x in y_true]\n        })\n        \n        fig = px.histogram(\n            df,\n            x='probability',\n            color='true_class',\n            nbins=50,\n            title=title,\n            opacity=0.7,\n            barmode='overlay'\n        )\n        \n        fig.update_layout(\n            xaxis_title='Predicted Probability of Infection',\n            yaxis_title='Count',\n            width=700,\n            height=400\n        )\n        \n        return fig\n    \n    def create_shap_summary_plot(self, model, X_sample, feature_names=None):\n        \"\"\"\n        Create feature importance plot for model interpretation (SHAP alternative)\n        \"\"\"\n        try:\n            # Use model's built-in feature importance if available\n            if hasattr(model, 'feature_importances_'):\n                importances = model.feature_importances_\n                if feature_names is None:\n                    feature_names = [f'Feature {i}' for i in range(len(importances))]\n                \n                fig = self.plot_feature_importance(feature_names, importances, top_n=20,\n                                                   title=\"Feature Importance for Model Interpretation\")\n                return fig\n            else:\n                print(\"Model does not have feature_importances_ attribute\")\n                return None\n            \n        except Exception as e:\n            print(f\"Could not create feature importance plot: {e}\")\n            return None\n    \n    def plot_calibration_curve(self, y_true, y_prob, n_bins=10, title=\"Calibration Curve\"):\n        \"\"\"\n        Plot calibration curve to assess probability calibration\n        \"\"\"\n        from sklearn.calibration import calibration_curve\n        \n        fraction_of_positives, mean_predicted_value = calibration_curve(\n            y_true, y_prob, n_bins=n_bins\n        )\n        \n        fig = go.Figure()\n        \n        # Perfect calibration line\n        fig.add_trace(go.Scatter(\n            x=[0, 1],\n            y=[0, 1],\n            mode='lines',\n            name='Perfect Calibration',\n            line=dict(dash='dash', color='gray')\n        ))\n        \n        # Calibration curve\n        fig.add_trace(go.Scatter(\n            x=mean_predicted_value,\n            y=fraction_of_positives,\n            mode='lines+markers',\n            name='Model Calibration',\n            line=dict(color=self.colors[0], width=3),\n            marker=dict(size=8)\n        ))\n        \n        fig.update_layout(\n            title=title,\n            xaxis_title='Mean Predicted Probability',\n            yaxis_title='Fraction of Positives',\n            xaxis=dict(range=[0, 1]),\n            yaxis=dict(range=[0, 1]),\n            width=600,\n            height=400\n        )\n        \n        return fig\n    \n    def create_model_comparison_dashboard(self, model_results):\n        \"\"\"\n        Create comprehensive model comparison dashboard\n        \"\"\"\n        metrics = ['accuracy', 'precision', 'recall', 'f1', 'roc_auc']\n        models = list(model_results.keys())\n        \n        # Create subplots\n        fig = make_subplots(\n            rows=2, cols=3,\n            subplot_titles=['Accuracy', 'Precision', 'Recall', 'F1 Score', 'ROC AUC', 'Overall Comparison'],\n            specs=[[{\"type\": \"bar\"}, {\"type\": \"bar\"}, {\"type\": \"bar\"}],\n                   [{\"type\": \"bar\"}, {\"type\": \"bar\"}, {\"type\": \"radar\"}]]\n        )\n        \n        positions = [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2)]\n        \n        # Individual metric plots\n        for i, metric in enumerate(metrics):\n            if i < 5:\n                row, col = positions[i]\n                values = [model_results[model][metric] for model in models]\n                \n                fig.add_trace(\n                    go.Bar(\n                        x=models,\n                        y=values,\n                        name=metric.title(),\n                        marker_color=self.colors[i % len(self.colors)],\n                        showlegend=False\n                    ),\n                    row=row, col=col\n                )\n        \n        # Radar chart for overall comparison\n        for i, model in enumerate(models):\n            values = [model_results[model][metric] for metric in metrics]\n            values.append(values[0])  # Close the radar chart\n            \n            fig.add_trace(\n                go.Scatterpolar(\n                    r=values,\n                    theta=metrics + [metrics[0]],\n                    fill='toself',\n                    name=model,\n                    line_color=self.colors[i % len(self.colors)]\n                ),\n                row=2, col=3\n            )\n        \n        fig.update_layout(\n            title=\"Model Performance Comparison Dashboard\",\n            height=800,\n            width=1200,\n            polar=dict(\n                radialaxis=dict(\n                    visible=True,\n                    range=[0, 1]\n                )\n            )\n        )\n        \n        return fig\n    \n    def plot_risk_stratification(self, y_true, y_pred_proba, title=\"Risk Stratification Analysis\"):\n        \"\"\"\n        Analyze model performance across different risk thresholds\n        \"\"\"\n        thresholds = np.arange(0.1, 1.0, 0.1)\n        \n        sensitivity_scores = []\n        specificity_scores = []\n        ppv_scores = []\n        npv_scores = []\n        \n        for threshold in thresholds:\n            y_pred_thresh = (y_pred_proba >= threshold).astype(int)\n            \n            tn, fp, fn, tp = confusion_matrix(y_true, y_pred_thresh).ravel()\n            \n            sensitivity = tp / (tp + fn) if (tp + fn) > 0 else 0\n            specificity = tn / (tn + fp) if (tn + fp) > 0 else 0\n            ppv = tp / (tp + fp) if (tp + fp) > 0 else 0\n            npv = tn / (tn + fn) if (tn + fn) > 0 else 0\n            \n            sensitivity_scores.append(sensitivity)\n            specificity_scores.append(specificity)\n            ppv_scores.append(ppv)\n            npv_scores.append(npv)\n        \n        fig = go.Figure()\n        \n        fig.add_trace(go.Scatter(\n            x=thresholds,\n            y=sensitivity_scores,\n            mode='lines+markers',\n            name='Sensitivity',\n            line=dict(color=self.colors[0])\n        ))\n        \n        fig.add_trace(go.Scatter(\n            x=thresholds,\n            y=specificity_scores,\n            mode='lines+markers',\n            name='Specificity',\n            line=dict(color=self.colors[1])\n        ))\n        \n        fig.add_trace(go.Scatter(\n            x=thresholds,\n            y=ppv_scores,\n            mode='lines+markers',\n            name='PPV',\n            line=dict(color=self.colors[2])\n        ))\n        \n        fig.add_trace(go.Scatter(\n            x=thresholds,\n            y=npv_scores,\n            mode='lines+markers',\n            name='NPV',\n            line=dict(color=self.colors[3])\n        ))\n        \n        fig.update_layout(\n            title=title,\n            xaxis_title='Prediction Threshold',\n            yaxis_title='Score',\n            yaxis=dict(range=[0, 1]),\n            width=700,\n            height=400\n        )\n        \n        return fig\n    \n    def calculate_clinical_metrics(self, y_true, y_pred_proba, threshold=0.5):\n        \"\"\"\n        Calculate clinical performance metrics\n        \"\"\"\n        y_pred = (y_pred_proba >= threshold).astype(int)\n        \n        tn, fp, fn, tp = confusion_matrix(y_true, y_pred).ravel()\n        \n        metrics = {\n            'sensitivity': tp / (tp + fn) if (tp + fn) > 0 else 0,\n            'specificity': tn / (tn + fp) if (tn + fp) > 0 else 0,\n            'ppv': tp / (tp + fp) if (tp + fp) > 0 else 0,\n            'npv': tn / (tn + fn) if (tn + fn) > 0 else 0,\n            'accuracy': (tp + tn) / (tp + tn + fp + fn),\n            'prevalence': (tp + fn) / (tp + tn + fp + fn),\n            'lr_positive': (tp / (tp + fn)) / (fp / (tn + fp)) if (fp / (tn + fp)) > 0 else float('inf'),\n            'lr_negative': (fn / (tp + fn)) / (tn / (tn + fp)) if (tn / (tn + fp)) > 0 else float('inf')\n        }\n        \n        return metrics\n\nif __name__ == \"__main__\":\n    # Test the utility functions\n    print(\"Model utilities loaded successfully!\")\n    \n    # Generate sample data for testing\n    np.random.seed(42)\n    n_samples = 1000\n    \n    y_true = np.random.binomial(1, 0.3, n_samples)\n    y_pred_proba = np.random.beta(2, 5, n_samples)\n    y_pred_proba[y_true == 1] += np.random.normal(0, 0.2, (y_true == 1).sum())\n    y_pred_proba = np.clip(y_pred_proba, 0, 1)\n    \n    utils = ModelUtils()\n    \n    # Test clinical metrics\n    metrics = utils.calculate_clinical_metrics(y_true, y_pred_proba)\n    print(\"Clinical metrics calculated successfully!\")\n    print(f\"Sensitivity: {metrics['sensitivity']:.3f}\")\n    print(f\"Specificity: {metrics['specificity']:.3f}\")\n","size_bytes":15667},"README.md":{"content":"# H. Pylori Infection Prediction System\n\nA clinical decision support tool powered by Machine Learning and AI for predicting H. Pylori infection risk in patients.\n\n## 🎯 Overview\n\nThis application uses advanced machine learning algorithms to predict the probability of H. Pylori infection based on patient demographics, clinical history, laboratory values, and lifestyle factors. It provides:\n\n- **Risk Prediction**: Probability scores and risk categorization (Low/Medium/High)\n- **AI-Powered Treatment Recommendations**: Personalized treatment plans using OpenAI GPT or Google Gemini\n- **Model Performance Metrics**: Transparent view of model accuracy and reliability\n- **Clinical Decision Support**: Evidence-based recommendations following medical guidelines\n\n## 📊 Model Performance\n\nThe system uses a **Random Forest** classifier trained on 1,000 synthetic patient records:\n\n- **ROC-AUC Score**: 85.2%\n- **Accuracy**: 78.5%\n- **Precision**: 71.2%\n- **Recall**: 66.2%\n- **Cross-validation ROC-AUC**: 90.5% (± 4.1%)\n\n## 🚀 Quick Start\n\n### Prerequisites\n\n- Python 3.11+\n- OpenAI API key or Google Gemini API key (for AI recommendations)\n\n### Setup Instructions\n\nThe system has already been set up with:\n1. ✅ Synthetic training data generated (1,000 patient records)\n2. ✅ Model trained and validated\n3. ✅ Best model saved and ready to use\n\n### Running the Application\n\nThe application is already running! Access it at:\n```\nhttp://localhost:5000\n```\n\n## 📝 How to Use\n\n### 1. **Patient Prediction Page** (Main Page)\n   - Enter patient demographic information\n   - Input clinical history and symptoms\n   - Provide laboratory values\n   - Add lifestyle and family history data\n   - Click \"Predict H. Pylori Risk\"\n   - View risk probability and category\n   - Generate AI-powered treatment recommendations\n\n### 2. **Model Performance Page**\n   - View comprehensive model metrics\n   - Compare different ML algorithms\n   - Analyze ROC curves and confusion matrices\n   - Understand model reliability\n\n### 3. **AI Settings Page**\n   - Configure OpenAI or Google Gemini API keys\n   - Select preferred AI provider\n   - Test connection to ensure proper setup\n\n## 🔬 Features Included\n\n### Patient Data Input\n- **Demographics**: Age, Sex, Residence, Education, Marital Status, Family Size\n- **Clinical History**: BMI, Gastritis History, Ulcer History\n- **Laboratory Values**: Albumin, WBC Count, Lymphocyte, Neutrophil, RBC, Hemoglobin\n- **Lifestyle Factors**: Smoking, Alcohol, Water Source, Pickled Food, Handwashing, Tableware Sharing\n- **Family History**: H. Pylori infection, Gastritis\n- **Endoscopy Findings**: Gastric Nodularity, Mucosal Redness (optional)\n\n### Model Features\n- **Feature Engineering**: 35 engineered features from 26 original inputs\n- **Advanced ML Pipeline**: Multiple algorithms compared (Logistic Regression, Random Forest, XGBoost, Gradient Boosting, SVM)\n- **Class Balancing**: SMOTE applied for handling class imbalance\n- **Cross-Validation**: 5-fold stratified validation for robust performance\n\n### AI Recommendations\n- **Evidence-Based**: Following ACG, AGA, and Maastricht VI guidelines\n- **Personalized**: Tailored to patient risk profile and clinical features\n- **Comprehensive**: Includes diagnostic tests, treatment plans, lifestyle modifications, and follow-up care\n\n## 📂 Project Structure\n\n```\n.\n├── app.py                      # Main Streamlit application\n├── data_generator.py           # Synthetic data generation\n├── ml_pipeline.py              # ML model training and prediction\n├── ai_recommendations.py       # AI-powered treatment recommendations\n├── model_utils.py              # Visualization and utilities\n├── data/\n│   └── training_data.csv       # Training dataset (1,000 patients)\n└── models/\n    ├── best_model.joblib       # Trained Random Forest model\n    ├── preprocessor.joblib     # Feature preprocessing pipeline\n    └── best_model_metadata.joblib  # Model metadata\n```\n\n## 🔑 Configuring AI Recommendations\n\n### Option 1: Using the UI (Recommended)\n1. Navigate to **AI Settings** page in the app\n2. Enter your API key for OpenAI or Google Gemini\n3. Click \"Test AI Connection\" to verify\n4. Go back to Patient Prediction and generate recommendations\n\n### Option 2: Using Environment Variables\nSet environment variables before starting the app:\n```bash\nexport OPENAI_API_KEY=\"your-openai-api-key\"\n# OR\nexport GEMINI_API_KEY=\"your-gemini-api-key\"\n```\n\n### Getting API Keys\n- **OpenAI**: https://platform.openai.com/api-keys\n- **Google Gemini**: https://aistudio.google.com/apikey\n\n## ⚠️ Important Notes\n\n### Clinical Use\n- This tool is designed for **clinical decision support only**\n- It assists healthcare professionals in risk assessment\n- **Should not replace professional medical judgment**\n- Always consult with qualified healthcare providers for diagnosis and treatment\n\n### Data Privacy\n- No patient data is stored permanently\n- API keys are stored only in the session (not saved to disk)\n- For production use, implement proper security measures\n\n### Model Limitations\n- Trained on synthetic data simulating real-world patterns\n- Performance may vary with actual patient populations\n- Regular validation with real data is recommended\n- Consider local antibiotic resistance patterns for treatment\n\n## 🛠️ Technical Details\n\n### Machine Learning Pipeline\n1. **Data Preprocessing**: Standardization, missing value handling\n2. **Feature Engineering**: Derived features, interaction terms, risk scores\n3. **Model Training**: Multiple algorithms with hyperparameter tuning\n4. **Validation**: Cross-validation, ROC-AUC, confusion matrices\n5. **Prediction**: Real-time inference with probability calibration\n\n### Supported Models\n- Logistic Regression\n- Random Forest (currently selected as best)\n- XGBoost\n- Gradient Boosting\n- Support Vector Machine\n\n### Technologies Used\n- **Framework**: Streamlit\n- **ML Libraries**: Scikit-learn, XGBoost, Imbalanced-learn\n- **Data Processing**: Pandas, NumPy\n- **Visualization**: Plotly\n- **AI Integration**: OpenAI GPT-5, Google Gemini 2.5 Pro\n\n## 📈 Future Enhancements\n\nPotential features for future versions:\n- Batch prediction for multiple patients via CSV upload\n- Model retraining pipeline with new patient data\n- Patient history tracking and longitudinal analysis\n- PDF export for prediction reports\n- Real-time model performance monitoring\n\n## 📄 License\n\nThis is a clinical decision support tool for educational and research purposes.\n\n## 👨‍⚕️ For Healthcare Professionals\n\nThis tool provides:\n- **Risk Stratification**: Identify high-risk patients for targeted intervention\n- **Evidence-Based Guidance**: Treatment recommendations following international guidelines\n- **Clinical Context**: Interpretable predictions with feature importance\n- **Workflow Integration**: Easy-to-use interface for busy clinical settings\n\n---\n\n**Disclaimer**: This application is provided as-is for educational purposes. Always consult with qualified medical professionals for patient care decisions.\n","size_bytes":7088}},"version":2}